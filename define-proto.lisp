;;; Copyright 2012-2020 Google LLC
;;;
;;; Use of this source code is governed by an MIT-style
;;; license that can be found in the LICENSE file or at
;;; https://opensource.org/licenses/MIT.

(in-package "PROTO-IMPL")


;;; Protocol buffer defining macros


#|
Notes on macroexpansion:

The lisp generated proto file should look like:

-------------------------------

;; In a package named "cl-protobufs.<the-proto-package-name>"

(proto:define-message color-wheel1
    (:conc-name "")
  ;; Nested messages.
  (proto:define-message color-wheel1.metadata1
      (:conc-name "")
    ;; Fields.
    (author  :index 1  :type cl:string :label (:optional) :typename "string")
    (revision  :index 2  :type cl:string :label (:optional) :typename "string")
    (date  :index 3  :type cl:string :label (:optional) :typename "string"))
  ;; Fields.
  (name  :index 1  :type cl:string :label (:required) :typename "string")
  (colors  :index 2  :type (proto:list-of color1) :label (:repeated :list)
           :typename "Color1")
  (metadata  :index 3  :type (cl:or cl:null color-wheel1.metadata1)
             :label (:optional) :typename "Metadata1"))

(cl:setf (cl:gethash #P"third_party/lisp/cl_protobufs/tests/serialization.proto"
                     proto-impl::*all-schemas*)
         (proto:find-schema 'serialization-test))

(export ...)
-------------------------------

The define-schema form stores the file-descriptor for the current file in
*current-file-descriptor*. The file-descriptor holds the protobuf-service
objects that are generated by the define-service macro.

TODO(jgodbout): Remove all schema.

Next we get into the define-* macro's.

The possible top level define macros are:
- define-enum
- define-message
- define-extend
- define-service

Inside of those macros there may also be define-* macros:
- define-enum
- define-message
- define-group
- define-extension
- define-extend
- define-service
- define-map
- define-oneof

The most common define-* macros we will see are the macros that
define messages, which generate PROTOBUF-MESSAGE classes and
create the message structures that hold data. These are:
- define-message
- define-group
- define-extend

DEFINE-ENUM:

The define-enum macro creates a ENUM-DESCRIPTOR meta-object as well
as a type with enum-name being (MEMBER :enum-1 :enum-2 ...).
It also creates methods to access the default-enum, and convert
from the enum keyword to the enum index and back.

If the enum being defined is at top level in the proto then
then we output the result of the macro directly.
If the enum is nested in other define forms, then we
save the output of define-enum in a global and output the
enum definitions before any other definitions. This guarantees
the enum type is available for other messages definitions.

DEFINE-EXTENSION:

The define-extension macro defines a PROTOBUF-EXTENSION meta-object and
set it in a PROTOBUF-MESSAGE meta-object.

This meta-object details the possible range indices of proto extensions
allowed in a protobuf message.

DEFINE-EXTEND:

The define-extend macro creates a PROTOBUF-MESSAGE meta-object that
overrides a PROTOBUF-MESSAGE meta-object created in define-message or
define-group. The new meta-object will be identical to the original
but with extra fields.

We return forms to create this meta-object as well as accessors and
setters for the new fields.

DEFINE-MESSAGE DEFINE-GROUP:

The define-message and define-group macros work much the same way.
They take the type (message name) and a list of sub-elements which
may include define-message, define-group, define-extension, define-extend,
define-enum, or a field which is just a declaration of the field object in a proto.

Example:   (author  :index 1  :type cl:string :label (:optional) :typename "string")

First we create the PROTOBUF-MESSAGE meta-object that is defined in the
define-message lambda list and store it in *current-message-descriptor*.  If we
see a define-message or define-group we recursively call the define macro to
create a subgroup which will be named:

  top-level-message.submessage1.submessage2

We save the resultant forms that are output as so define-message or define-group
may output them at the and of the macro-call.

If we see a define-enum, define-message, or define-extend macro
we save the resultant form to a list of forms to output.

If we see a define-group form we call it and it creates a message just like
define-message. The only difference is a group acts as a field in a message
as well as being an message type in the message, so we must add a field to the
PROTOBUF-MESSAGE meta-object as if it were a field.

If we see a field we call process-field which creates a FIELD-DESCRIPTOR
containing details of the field and returns a form to create this meta-object.
We save the form for both output and future processing.

Next we call MAKE-STRUCTURE-CLASS-FORMS that takes the field meta-objects
and creates forms for creating defstruct form for the proto data container
that will be used in client code. This is where the accessors, setters, and has
functions are defined. It outputs all of the forms to create these objects.

Finally we output all of the created forms.

DEFINE-SERVICE:

The define-service macro creates forms that make the SERVICE-DESCRIPTOR, add it to the
PROTOBUF-SCHEMA meta-object, and create method stubs for the service implementation.

Note: Actually using services require a gRPC plugin.

DEFINE-ONEOF:

The define-oneof macro takes a body of field defintions and creates a ONEOF-DESCRIPTOR
meta-object which holds field descriptors for the fields in its body. This
ONEOF-DESCRIPTOR gets appended to the message's PROTO-ONEOFS slot. Then,
MAKE-STRUCTURE-CLASS-FORMS will use the PROTO-ONEOFS slot to create forms for accessing
the oneof and its nested fields.
|#


;; TODO(jgodbout): remove this, we already have field-descriptor
(defstruct field-data
  "Keep field metadata for making the structure object."
  (internal-slot-name nil :type symbol)
  (external-slot-name nil :type symbol)
  (accessor nil)
  (type nil)
  (initarg nil)
  (initform nil))

(defun validate-imports (file-descriptor imports)
  "Validates that all of the IMPORTS (a list of file names) have
   already been loaded. FILE-DESCRIPTOR is the descriptor of the
   file doing the importing."
  (dolist (import (reverse imports))
    (let* ((imported (proto:find-schema (if (stringp import) (pathname import) import))))
      (unless imported
        (error "Could not find file ~S imported by ~S" import file-descriptor)))))

(defun define-schema (type &key name syntax package import
                           optimize options documentation)
  "Define a schema named TYPE, corresponding to a .proto file of that name.
   NAME can be used to override the defaultly generated Protobufs name.
   SYNTAX and PACKAGE are as they would be in a .proto file.
   IMPORT is a list of pathname strings to be imported.
   OPTIMIZE can be either :space (the default) or :speed; if it is :speed, the
   serialization code will be much faster, but much less compact.
   OPTIONS is a property list, i.e., (\"key1\" \"val1\" \"key2\" \"val2\" ...).
   DOCUMENTATION is the documentation for the proto."
  (let* ((name     (or name (class-name->proto type)))
         (package  (and package (if (stringp package)
                                    package
                                    (string-downcase (string package)))))
         (options  (remove-options
                    (loop for (key val) on options by #'cddr
                          collect (make-option
                                   (if (symbolp key)
                                       (slot-name->proto key)
                                       key)
                                   val))
                    "optimize_for"))
         (imports  (if (listp import) import (list import)))
         (schema   (make-instance
                    'file-descriptor
                    :class    type
                    :name     name
                    ;; CCL requires syntax to be OR'd  with :proto2 or :proto3
                    ;; in case syntax is NIL.
                    :syntax   (or syntax :proto2 :proto3)
                    :package  package
                    :imports  imports
                    :options  (if optimize
                                  (append options
                                          (list (make-option
                                                 "optimize_for"
                                                 (if (eq optimize :speed)
                                                     "SPEED"
                                                     "CODE_SIZE")
                                                 'symbol)))
                                  options)
                    :documentation documentation)))
    (record-schema schema)
    (setf *current-file-descriptor* schema)
    (validate-imports schema imports)))

(defun %make-enum->numeral-table (enum-values)
  "Makes a hash table mapping enum values to numerals.
ENUM-VALUES is a list of ENUM-VALUE-DESCRIPTORs."
  `(case enum
     ,@(loop for v in enum-values
             collect
             `(,(enum-value-descriptor-name v) ,(enum-value-descriptor-value v)))))

(defun %make-numeral->enum-table (enum-values)
  "Makes a hash table mapping enum values to numerals.
ENUM-VALUES is a list of ENUM-VALUE-DESCRIPTORs."
  `(case numeral
     ,@(loop with mapped = (make-hash-table)
             for v in enum-values
             for enum-value = (enum-value-descriptor-value v)
             for already-set-p = (gethash enum-value mapped)
             unless already-set-p
               do (setf (gethash enum-value mapped) t)
             unless already-set-p
               collect `(,enum-value ,(enum-value-descriptor-name v)))))

(deftype numeral () "byte 32" '(signed-byte 32))

(defgeneric cl-protobufs:numeral->enum (enum numeral &optional default)
  (:documentation
   "Converts a NUMERAL to a corresponding ENUM keyword.
ENUM is a Lisp symbol name of the ENUM.
DEFAULT the default value if NUMERAL in not contained in the ENUM."))

(deftype quoted-symbol () "(quote sym)" '(cons (eql quote) (cons symbol)))

(defgeneric cl-protobufs:enum->numeral (enum keyword &optional default)
  (:documentation
   "Converts an ENUM keyword to a corresponding ENUM KEYWORD.
ENUM is a Lisp symbol name of the ENUM.
DEFAULT the default value if KEYWORD is a not contained in ENUM."))

(defun make-enum<->numeral-forms (type enum-values)
  "Generates forms for enum<->numeral conversion functions.
TYPE is the enum type name.  ENUM-VALUES is a list of ENUM-VALUE-DESCRIPTORs."
  (let ((enum->numeral (fintern "~A->NUMERAL" type))
        (numeral->enum (fintern "NUMERAL->~A" type)))
    `(progn
       (defun ,enum->numeral (enum &optional default)
         (declare (symbol enum))
         (let ((numeral ,(%make-enum->numeral-table enum-values)))
           (if numeral numeral default)))

       (defun ,numeral->enum (numeral &optional default)
         (declare (numeral numeral))
         (let ((enum ,(%make-numeral->enum-table enum-values)))
           (if enum enum default)))

       (setf (get ',type 'numeral->enum) ',numeral->enum)
       (setf (get ',type 'enum->numeral) ',enum->numeral)

       (defmethod cl-protobufs:enum->numeral
           ((e (eql ',type)) keyword &optional default)
         (,enum->numeral keyword default))
       (defmethod cl-protobufs:numeral->enum
           ((e (eql ',type)) numeral &optional default)
         (,numeral->enum numeral default)))))

(defgeneric enum-default-value (enum-type)
  (:documentation
   "Get the default enum value for ENUM-TYPE"))

(defmethod enum-default-value (enum-type)
  "If no default enum value function can be found for a specific ENUM-TYPE
return nil."
  nil)

(defun make-enum-default (type enum-values)
  "Generate a function to return the default enum value for
an enum of type TYPE. The default value should be the first
enum in ENUM-VALUES."
  `(defmethod enum-default-value ((e (eql ',type)))
     ,(enum-value-descriptor-name (car enum-values))))

(defun make-enum-constant-forms (type enum-values)
  "Generates forms for defining a constant for each enum value in ENUM-VALUES.
TYPE is the enum type name.  ENUM-VALUES is a list of ENUM-VALUE-DESCRIPTORs.

Constant names are in the form of +<message_name>.<value_name>+ when the enum is defined in a
message, and of +<value_name>+ when the enum is defined at top-level."
  (let* ((enum-name (symbol-name type))
         (dot (position #\. enum-name :test #'char= :from-end t))
         ;; Use C/C++ enum scope.
         (scope (and dot (subseq enum-name 0 dot)))
         (constants
          (loop for v in enum-values
                for c = (fintern "+~@[~A.~]~A+" scope (enum-value-descriptor-name v))
                collect `(defconstant ,c ,(enum-value-descriptor-value v)))))
    `(progn
       ,@constants
       (export ',(mapcar #'second constants)))))

(defun enum-values (enum-type)
  "Returns all keyword values that belong to the given ENUM-TYPE."
  (let ((expansion (type-expand enum-type)))
    (check-type expansion (cons (eql member) list))
    (rest expansion)))

(defvar *enum-forms* nil
  "The enum forms have to be evaluated first as they become types
for messages and sadly the messages can be defined before the enums.")

(defun create-progn-with-enum-forms-if-top-level (top-level-form-p &rest lists)
  "Create the output progn form for a define statement which may be top-level
and have an enum inside of it. If it is top level output the internal enums
before the rest of the forms, otherwise just output the forms collected.
Parameters:
  TOP-LEVEL-FORM-P: Bool stating whether this is top-level or not.
  LISTS: The lists that have been collected in the defining form for output."
  (let (out-list)
    ;; Our foolish version of one-level flatten
    (dolist (list (reverse lists))
      (dolist (inner-list (reverse list))
        (push inner-list out-list)))

    (if (and top-level-form-p *enum-forms*)
        (let ((output
               `(progn ,@*enum-forms* ,@out-list)))
          (setf *enum-forms* nil)
          output)
        `(progn ,@out-list))))

(defmacro define-enum (type (&key name conc-name alias-for)
                       &body values)
  "Define a Lisp type given the data for a protobuf enum type.
Also generates conversion functions between enum values and numerals.  Function names are
<enum_name>->NUMERAL and NUMERAL-><enum_name>, respectively.
Both accept an optional default argument.

Parameters:
  TYPE: The name of the type.
  NAME: Override for the protobuf enum type name.
  CONC-NAME: Prefix to the defaultly generated protobuf enum name.
  ALIAS-FOR: Make this enum an alias for another type.
  VALUES: The possible values for the enum in the form (name :index value)."
  (let ((name (or name (class-name->proto type)))
        (prefix (conc-name-for-type type conc-name)))
    (with-collectors ((names collect-name) ; keyword symbols
                      (forms collect-form)
                      (value-descriptors collect-value-descriptor))
      ;; The middle value is :index, useful for readability of generated code...
      ;; (Except that the value is not actually an index, nor is the slot called index anymore.)
      (loop for (name nil value) in values do
        (let* ((val-name (kintern (if prefix
                                      (format nil "~A~A" prefix name)
                                      (symbol-name name))))
               (val-desc (make-enum-value-descriptor :value value :name val-name)))
          (collect-name val-name)
          (collect-value-descriptor val-desc)))
      (let ((enum (make-enum-descriptor
                   :class  type
                   :name   name
                   :alias-for (if (listp alias-for)
                                  alias-for
                                  (list alias-for))
                   :values value-descriptors)))
        (cond ((and alias-for (not (eq type alias-for)))
               ;; If we've got an alias, define a type that is a subtype of
               ;; the Lisp enum so that typep and subtypep work.
               (collect-form `(deftype ,type () ',alias-for)))
              ((null alias-for)
               (collect-form `(deftype ,type () '(member ,@names)))
               (collect-form (make-enum<->numeral-forms type value-descriptors))
               (collect-form (make-enum-constant-forms type value-descriptors))
               (collect-form (make-enum-default type value-descriptors))))
        (collect-form `(record-protobuf-object ',type ,enum :enum))
        ;; Register it by the full symbol name.
        (record-protobuf-object type enum :enum))
      ;; This is messy and should be fixed.
      ;; Enums define types and functions that will need to be called
      ;; when creating messages. As such they need to be first
      ;; in the list of things a macro evaluated. So we make a global var
      ;; and gaurantee they are first.
      (when *current-message-descriptor* ; enum is nested inside a message
        (push `(progn ,@forms) *enum-forms*))
      `(progn ,@forms))))

(defmacro define-map (type-name &key key-type val-type index)
"Define a lisp type given the data for a protobuf map type.

Parameters:
  TYPE-NAME: Map type name.
  KEY-TYPE: The lisp type of the map's keys.
  VAL-TYPE: The lisp type of the map's values.
  INDEX: Index of this map type in the field."
  (check-type index integer)
  (let* ((slot      type-name)
         (name      (class-name->proto type-name))
         (reader    (let ((msg-conc (proto-conc-name *current-message-descriptor*)))
                      (and msg-conc
                           (fintern "~A~A" msg-conc slot))))
         (internal-slot-name (fintern "%~A" slot))
         (qual-name (make-qualified-name *current-message-descriptor* (slot-name->proto slot)))
         (class (fintern (uncamel-case qual-name)))
         (mslot  (make-field-data
                  :internal-slot-name internal-slot-name
                  :external-slot-name slot
                  :type 'hash-table
                  :initform '(make-hash-table)
                  :accessor reader))
         (mfield (make-instance 'field-descriptor
                  :name (slot-name->proto slot)
                  :type "map"
                  :class class
                  :qualified-name qual-name
                  :set-type :map
                  :label :optional
                  :index index
                  :internal-field-name internal-slot-name
                  :external-field-name slot
                  :reader reader))
         (map-desc (make-map-descriptor
                    :class class
                    :name name
                    :key-class (lisp-type-to-protobuf-class key-type)
                    :val-class (lisp-type-to-protobuf-class val-type)
                    :key-type key-type
                    :val-type val-type)))
    (record-protobuf-object class map-desc :map)
    `(progn
       define-map ;; the type of this model
       map-desc   ;; the model data.
       ((record-protobuf-object ',class ,map-desc :map)) ;; forms necessary for defining the map
       ,mfield    ;; the extra field-data object created by this macro
       ,mslot)))  ;; the extra field-descriptor object created by this macro.

(defmacro define-oneof (name (&key (synthetic-p nil)) &body fields)
  "Define a protobuf oneof. This macro creates the representation for
the oneof, as well as the representation/defining forms for its fields.

Parameters:
  NAME: The name of the oneof.
  SYNTHETIC-P: If true, this oneof is automatically generated by protoc. In this case, the special
    oneof accessors should not be created.
  FIELDS: Field as output by protoc."
  (let* ((internal-name (fintern "%~A" name))
         (field-list (make-array (length fields))))
    (loop for field in fields
          for oneof-offset from 0
          do
       (destructuring-bind
           (slot &key type typename name (default nil default-p)
                 lazy index documentation &allow-other-keys)
           field
         (assert index)
         (let ((default (if default-p default $empty-default)))
           (multiple-value-bind (ptype pclass packed-p enum-values root-lisp-type)
               (clos-type-to-protobuf-type type)
             (declare (ignore packed-p enum-values))
             (setf (aref field-list oneof-offset)
                   (make-instance
                    'field-descriptor
                    :name (or name (slot-name->proto slot))
                    :type (or typename ptype)
                    :lisp-type (when root-lisp-type (qualified-symbol-name
                                                     root-lisp-type))
                    :set-type type
                    :class pclass
                    :qualified-name (make-qualified-name
                                     *current-message-descriptor*
                                     (or name (slot-name->proto slot)))
                    :label :optional
                    :index index
                    ;; Oneof fields don't have a bit in the %%is-set vector, but
                    ;; if they don't have an offset, then some code treats them
                    ;; as extension fields.
                    :field-offset nil
                    :internal-field-name internal-name
                    :external-field-name slot
                    :oneof-offset oneof-offset
                    :default default
                    :lazy (and lazy t)
                    :documentation documentation))))))
    `(progn
       ,(make-oneof-descriptor
         :internal-name internal-name
         :external-name name
         :synthetic-p (and synthetic-p t)
         :fields field-list))))

(declaim (inline proto-%bytes))
(defun proto-%bytes (obj)
  "Returns the %bytes field of the proto object OBJ."
  (slot-value obj '%bytes))

(declaim (inline (setf proto-%bytes)))
(defun (setf proto-%bytes) (new-value obj)
  "Sets the %bytes field of the proto object OBJ with NEW-VALUE."
  (setf (slot-value obj '%bytes) new-value))

(defstruct field-accessors
  "Structure containing the get, set, and has functions
for a proto-message field."
  (get nil :type symbol)
  (set nil :type list)
  (has nil :type symbol)
  (clear nil :type symbol))

(defun set-field-accessor-functions (message-name field-name)
  "Set the get, set, and has functions for a proto field on a fields symbol p-list.
Parameters:
  MESSAGE-NAME: The symbol name of the protobuf message containing the field.
  FIELD-NAME: The symbol name for the field."
  (setf (get field-name message-name)
        (make-field-accessors
         :get (proto-slot-function-name message-name field-name :get)
         :set `(setf ,(proto-slot-function-name message-name field-name :get))
         :has (proto-slot-function-name message-name field-name :has)
         :clear (proto-slot-function-name message-name field-name :clear))))

(defun make-common-forms-for-structure-class (proto-type public-slot-name slot-name field)
  "Create the common forms needed for all message fields
has, is-set, clear, set.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix).
  SLOT-NAME: Slot name for the field (with the #\% prefix).
  FIELD: The class object field definition of the field."
  (let ((public-accessor-name (proto-slot-function-name proto-type public-slot-name :get))
        (is-set-accessor (fintern "~A-%%IS-SET" proto-type))
        (hidden-accessor-name (fintern "~A-~A" proto-type slot-name))
        (has-function-name (proto-slot-function-name proto-type public-slot-name :has))
        (default-form (get-default-form (proto-set-type field)
                                        (proto-default field)))
        (index (proto-field-offset field))
        (clear-function-name (proto-slot-function-name proto-type public-slot-name :clear))
        (bool-index (proto-bool-index field))
        (bit-field-name (fintern "~A-%%BOOL-VALUES" proto-type))
        (label (proto-label field)))

    ;; If index is nil, then this field does not have a reserved bit in the %%is-set vector.
    ;; This means that the field is singular, so checking for field presence must be done by
    ;; checking if the bound value is default.
    (with-gensyms (obj new-value cur-value)
      `(
        (declaim (inline (setf ,public-accessor-name)))
        (defun (setf ,public-accessor-name) (,new-value ,obj)
          ,(when index
             `(setf (bit (,is-set-accessor ,obj) ,index) 1))
          ,(if bool-index
               `(setf (bit (,bit-field-name ,obj) ,bool-index)
                      (if ,new-value 1 0))
               `(setf (,hidden-accessor-name ,obj) ,new-value)))


        ;; For singular fields, the has-* function is repurposed. It now answers the question:
        ;; "Is this field bound to the default value?". This is done so that the optimized
        ;; serializer can use the has-* function to check if a singular field should be serialized.
        (declaim (inline ,has-function-name))
        (defun ,has-function-name (,obj)
          ,(if index
               `(= (bit (,is-set-accessor ,obj) ,index) 1)
               `(let ((,cur-value ,(if bool-index
                                       `(plusp (bit (,bit-field-name ,obj) ,bool-index))
                                       `(,hidden-accessor-name ,obj))))
                  ,(case (proto-set-type field)
                     ((proto:byte-vector cl:string) `(not (= (length ,cur-value) 0)))
                     ((cl:double-float cl:float) `(not (= ,cur-value ,default-form)))
                     ;; Otherwise, the type is integral. EQ suffices to check equality.
                     (t `(not (eq ,cur-value ,default-form)))))))

        ;; Clear function
        (declaim (inline ,clear-function-name))
        (defun ,clear-function-name (,obj)
          ,(if bool-index
               `(setf (bit (,bit-field-name ,obj) ,bool-index)
                      ,(if default-form 1 0))
               `(setf (,hidden-accessor-name ,obj) ,default-form))
          ,(when index
            `(setf (bit (,is-set-accessor ,obj) ,index) 0)))

        ;; Create defmethods to allow for getting/setting compatibly
        ;; with the standard-classes.
        (defmethod ,public-slot-name ((,obj ,proto-type))
          (,public-accessor-name ,obj))

        (defmethod (setf ,public-slot-name) (,new-value (,obj ,proto-type))
          (setf (,public-accessor-name ,obj) ,new-value))

        (proto-impl::set-field-accessor-functions ',proto-type ',public-slot-name)

        ;; has-* functions are not exported for singular fields. They are only for
        ;; internal usage.
        ,(unless (eq label :singular)
           `(export '(,has-function-name)))

        (export '(,clear-function-name ,public-accessor-name))))))

(defun make-oneof-accessor-forms (proto-type oneof)
  "Make and return forms that define accessor functions for a oneof and its fields.

Paramters:
  PROTO-TYPE: The lisp name of the containing message of this oneof.
  ONEOF: The oneof-descriptor of the oneof to make accessors for."
  (let* ((public-slot-name (oneof-descriptor-external-name oneof))
         (hidden-slot-name (oneof-descriptor-internal-name oneof))
         (hidden-accessor-name (fintern "~A-~A" proto-type hidden-slot-name))
         (case-function-name (proto-slot-function-name proto-type public-slot-name :case))
         (has-function-name (proto-slot-function-name proto-type public-slot-name :has))
         (clear-function-name (proto-slot-function-name proto-type public-slot-name :clear)))
    (with-gensyms (obj)
      `(
        ;; Since the oneof struct stores an integer to indicate which field is set, it is not
        ;; particularly useful for the user when writing code surrounding oneof types. This
        ;; creates a function which returns a symbol with the same name as the field which
        ;; is currently set. If the field is not set, this function returns nil.
        (declaim (inline ,case-function-name))
        (defun ,case-function-name (,obj)
          (ecase (oneof-set-field (,hidden-accessor-name ,obj))
            ,@(loop for field across (oneof-descriptor-fields oneof)
                    collect
                    `(,(proto-oneof-offset field) ',(proto-external-field-name field)))
            ((nil) nil)))

        (declaim (inline ,has-function-name))
        (defun ,has-function-name (,obj)
          (not (eql (oneof-set-field (,hidden-accessor-name ,obj)) nil)))

        (declaim (inline ,clear-function-name))
        (defun ,clear-function-name (,obj)
          (setf (oneof-value (,hidden-accessor-name ,obj)) nil)
          (setf (oneof-set-field (,hidden-accessor-name ,obj)) nil))

        ;; Special oneof forms are only created when ONEOF is not synthetic.
        ,(unless (oneof-descriptor-synthetic-p oneof)
           `(export '(,case-function-name ,has-function-name ,clear-function-name)))

        ;; Fields inside of a oneof need special accessors, since they need to consult
        ;; with the oneof struct. This creates those special accessors for each field.
        ;; This mostly mirrors what happens in make-common-forms-for-structure-class
        ;; and make-structure-class-forms-non-lazy, but they consult the oneof struct
        ;; to check if they are set.
        ,@(loop
            for field across (oneof-descriptor-fields oneof)
            append
            (let* ((public-slot-name (proto-external-field-name field))
                   (public-accessor-name (proto-slot-function-name
                                          proto-type public-slot-name :get))
                   (has-function-name    (proto-slot-function-name
                                          proto-type public-slot-name :has))
                   (clear-function-name  (proto-slot-function-name
                                          proto-type public-slot-name :clear))
                   (default-form (get-default-form (proto-set-type field)
                                                   (proto-default field)))
                   (field-type (proto-set-type field))
                   (oneof-offset (proto-oneof-offset field)))
              ;; If a field isn't currently set inside of the oneof, just return its
              ;; default value.
              (with-gensyms (obj new-value bytes field-obj)
                `((declaim (inline ,public-accessor-name))
                  (defun ,public-accessor-name (,obj)
                    (if (eq (oneof-set-field (,hidden-accessor-name ,obj))
                            ,oneof-offset)
                        ,(if (proto-lazy-p field)
                             `(let* ((,field-obj (oneof-value (,hidden-accessor-name ,obj)))
                                     (,bytes (and ,field-obj (proto-%bytes ,field-obj))))
                                (if ,bytes
                                    (setf (oneof-value (,hidden-accessor-name ,obj))
                                          (%deserialize-object ',(proto-class field)
                                                               ,bytes nil nil))))
                             `(oneof-value (,hidden-accessor-name ,obj)))
                        ,default-form))

                  (declaim (inline (setf ,public-accessor-name)))
                  (defun (setf ,public-accessor-name) (,new-value ,obj)
                    (declare (type ,field-type ,new-value))
                    (setf (oneof-set-field (,hidden-accessor-name ,obj))
                          ,oneof-offset)
                    (setf (oneof-value (,hidden-accessor-name ,obj)) ,new-value))

                  (declaim (inline ,has-function-name))
                  (defun ,has-function-name (,obj)
                    (eq (oneof-set-field (,hidden-accessor-name ,obj))
                        ,oneof-offset))

                  (declaim (inline ,clear-function-name))
                  (defun ,clear-function-name (,obj)
                    (when (,has-function-name ,obj)
                      (setf (oneof-value (,hidden-accessor-name ,obj)) nil)
                      (setf (oneof-set-field (,hidden-accessor-name ,obj)) nil)))

                  (defmethod ,public-slot-name ((,obj ,proto-type))
                    (,public-accessor-name ,obj))

                  (defmethod (setf ,public-slot-name) (,new-value (,obj ,proto-type))
                    (setf (,public-accessor-name ,obj) ,new-value))

                  (proto-impl::set-field-accessor-functions ',proto-type ',public-slot-name)

                  (export '(,has-function-name ,clear-function-name
                            ,public-accessor-name))))))))))

(defun make-map-accessor-forms (proto-type public-slot-name slot-name field)
  "This creates forms that define map accessors which are type safe. Using these will
guarantee that the resulting map can be properly serialized, whereas if one modifies
the underlying map (which is accessed via the make-common-forms-for-structure-class
function) then there is no guarantee on the serialize function working properly.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix).
  SLOT-NAME: Slot name for the field (with the #\% prefix).
  FIELD: The class object field definition of the field."
  (let* ((public-accessor-name (proto-slot-function-name proto-type public-slot-name :map-get))
         (public-remove-name (proto-slot-function-name proto-type public-slot-name :map-rem))
         (method-accessor-name (fintern "~A-gethash" public-slot-name))
         (method-remove-name (fintern "~A-remhash" public-slot-name))
         (hidden-accessor-name (fintern "~A-~A"  proto-type slot-name))
         (key-type (map-descriptor-key-type (find-map-descriptor (proto-class field))))
         (val-type (map-descriptor-val-type (find-map-descriptor (proto-class field))))
         (val-default-form (get-default-form val-type $empty-default))
         (is-set-accessor (fintern "~A-%%IS-SET" proto-type))
         (index (proto-field-offset field)))
    (with-gensyms (obj new-val new-key)
      `(
        (declaim (inline (setf ,public-accessor-name)))
        (defun (setf ,public-accessor-name) (,new-val ,new-key ,obj)
          (declare (type ,key-type ,new-key)
                   (type ,val-type ,new-val))
          (setf (bit (,is-set-accessor ,obj) ,index) 1)
          (setf (gethash ,new-key (,hidden-accessor-name ,obj)) ,new-val))

        ;; If the map's value type is a message, then the default value returned
        ;; should be nil. However, we do not want to allow the user to insert nil
        ;; into the map, so this binding only applies to the clear and get functions.
        ,@(let ((val-type (if (find-message val-type)
                              (list 'or 'null val-type)
                              val-type)))
            `((declaim (inline ,public-accessor-name))
              (defun ,public-accessor-name (,new-key ,obj)
                (declare (type ,key-type ,new-key))
                (the (values ,val-type t)
                     (multiple-value-bind (val flag)
                         (gethash ,new-key (,hidden-accessor-name ,obj))
                       (if flag
                           (values val flag)
                           (values ,val-default-form nil)))))

              (declaim (inline ,public-remove-name))
              (defun ,public-remove-name (,new-key ,obj)
                (declare (type ,key-type ,new-key))
                (remhash ,new-key (,hidden-accessor-name ,obj))
                (if (= 0 (hash-table-count (,hidden-accessor-name ,obj)))
                    (setf (bit (,is-set-accessor ,obj) ,index) 0)))))

        ;; These defmethods have the same functionality as the functions defined above
        ;; but they don't require a refernece to the message type, so using them is more
        ;; convenient.
        (defmethod (setf ,method-accessor-name) (,new-val ,new-key (,obj ,proto-type))
          (setf (,public-accessor-name ,new-key ,obj) ,new-val))

        (defmethod ,method-accessor-name (,new-key (,obj ,proto-type))
          (,public-accessor-name ,new-key ,obj))

        (defmethod ,method-remove-name (,new-key (,obj ,proto-type))
          (,public-remove-name ,new-key ,obj))

        (export '(,public-accessor-name
                  ,public-remove-name
                  ,method-accessor-name
                  ,method-remove-name))))))

(defun make-structure-class-forms-lazy (proto-type field public-slot-name)
  "Makes forms for the lazy fields of a proto message using STRUCTURE-CLASS.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  FIELD: The field definition for which to define accessors.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix)."
  (let* ((slot-name (proto-internal-field-name field))
         (repeated (eq (proto-label field) :repeated))
         (vectorp (vector-field-p field))
         (public-accessor-name (proto-slot-function-name proto-type public-slot-name :get))
         (hidden-accessor-name (fintern "~A-~A" proto-type slot-name)))
    (with-gensyms (obj field-obj bytes)
      `(
        ;; Public reader.
        (declaim (inline ,public-accessor-name))
        (defun ,public-accessor-name (,obj)
          ,(if (not repeated)
               `(let* ((,field-obj (,hidden-accessor-name ,obj))
                       (,bytes (and ,field-obj (proto-%bytes ,field-obj))))
                  (if ,bytes
                      (setf (,hidden-accessor-name ,obj)
                            ;; Re-create the field object by deserializing its %bytes
                            ;; field.
                            (%deserialize-object ',(proto-class field) ,bytes nil nil))
                      ,field-obj))
               `(let ((,field-obj (,hidden-accessor-name ,obj)))
                  (if (notany #'proto-%bytes ,field-obj)
                      ,field-obj
                      ,(with-gensyms (maybe-deserialize-object field-element)
                         `(flet ((,maybe-deserialize-object (,field-element)
                                   (let ((,bytes (proto-%bytes ,field-element)))
                                     (if ,bytes
                                         ;; Re-create the field object by deserializing
                                         ;; its %bytes field.
                                         (%deserialize-object ',(proto-class field) ,bytes nil nil)
                                         ,field-element))))
                            (setf (,hidden-accessor-name ,obj)
                                  ,(if vectorp
                                       `(map 'vector #',maybe-deserialize-object
                                             (the vector ,field-obj))
                                       `(mapcar #',maybe-deserialize-object ,field-obj)))))))))
        ,@(make-common-forms-for-structure-class proto-type public-slot-name slot-name field)))))

(defun make-structure-class-forms-non-lazy (proto-type field public-slot-name)
  "Makes forms for the non-lazy fields of a proto message.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  FIELD: The field definition for which to define accessors.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix)."
  (let* ((slot-name (proto-internal-field-name field))
         (public-accessor-name (proto-slot-function-name proto-type public-slot-name :get))
         (hidden-accessor-name (fintern "~A-~A" proto-type slot-name))
         (bool-index (proto-bool-index field))
         (bit-field-name (fintern "~A-%%BOOL-VALUES" proto-type)))
    (with-gensyms (obj)
      `((declaim (inline ,public-accessor-name))
        (defun ,public-accessor-name (,obj)
          ,(if bool-index
               `(plusp (bit (,bit-field-name ,obj) ,bool-index))
               `(,hidden-accessor-name ,obj)))

        ,@(make-common-forms-for-structure-class
           proto-type public-slot-name slot-name field)

        ;; Make special map forms.
        ,@(when (typep (find-map-descriptor (proto-class field)) 'map-descriptor)
            (make-map-accessor-forms
             proto-type public-slot-name slot-name field))))))


(let ((default-form (make-hash-table)))
  (setf (gethash 'cl:double-float default-form) 0.0d0)
  (setf (gethash 'cl:float default-form) 0.0)
  (setf (gethash 'proto:int64 default-form)
        (coerce 0 'proto:int64))
  (setf (gethash 'proto:uint64 default-form)
        (coerce 0 'proto:uint64))
  (setf (gethash 'proto:int32 default-form)
        (coerce 0 'proto:int32))
  (setf (gethash 'proto:fixed64 default-form)
        (coerce 0 'proto:fixed64))
  (setf (gethash 'proto:fixed32 default-form)
        (coerce 0 'proto:fixed32))
  (setf (gethash 'proto:sfixed64 default-form)
        (coerce 0 'proto:sfixed64))
  (setf (gethash 'proto:sfixed32 default-form)
        (coerce 0 'proto:sfixed32))
  (setf (gethash 'cl:boolean default-form) nil)
  (setf (gethash 'cl:string default-form) "")
  (setf (gethash 'proto:byte-vector default-form)
        '(make-byte-vector 0 :adjustable t))
  (setf (gethash 'proto:uint32 default-form)
        (coerce 0 'proto:uint32))
  (setf (gethash 'proto:sint32 default-form)
        (coerce 0 'proto:sint32))
  (setf (gethash 'proto:sint64 default-form)
        (coerce 0 'proto:sint64))
  ;; One of the "Home grown types..."
  (setf (gethash 'cl:keyword default-form)
        :default-keyword)
  (defun get-default-form (type default)
    "Get the default value for TYPE and the proto set DEFAULT"
    (let ((possible-default (gethash type default-form)))
      (cond
        ((not (member default
                      (list $empty-vector $empty-list $empty-default nil)))
         default)
        ((or possible-default
             (eq type 'cl:boolean))
         possible-default)
        ((and (listp type)
              (eq (first type) 'cl-protobufs:vector-of))
         '(make-array 0 :adjustable t))
        ((and (listp type)
              (eq (first type) 'cl-protobufs:list-of))
         nil)
        ((and (listp type)
              (eq (first type) 'cl:or)
              (eq (second type) 'cl:null))
         nil)
        ((eq type :map)
         '(make-hash-table))
        ((enum-default-value `,type) (enum-default-value `,type))
        (t `(enum-default-value ',type))))))

(defun make-structure-class-forms (proto-type slots non-lazy-fields lazy-fields oneofs)
  "Makes the definition forms for the define-group and define-message macros.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  SLOTS: Slot definitions created by PROCESS-FIELD.
  NON-LAZY-FIELDS: Field definitions for non-lazy fields.
  LAZY-FIELDS: Field definitions for lazy fields.
  ONEOFS: A list of oneof descriptors for the message/group."
  (let* ((public-constructor-name (fintern "MAKE-~A" proto-type))
         (hidden-constructor-name (fintern "%MAKE-~A" proto-type))
         (public-lazy-slot-names (mapcar #'proto-external-field-name lazy-fields))
         (public-non-lazy-slot-names (mapcar #'proto-external-field-name non-lazy-fields))
         (is-set-name (fintern "~A-%%IS-SET" proto-type))
         (clear-is-set-name (fintern "~A.CLEAR-%%IS-SET" proto-type))
         (is-set-init (field-data-initform
                       (find-if #'(lambda (el)
                                    (eq (field-data-internal-slot-name el) '%%is-set))
                                slots)))
         (additional-slots '(%%is-set))
         (oneof-fields (loop for oneof in oneofs
                             append (coerce (oneof-descriptor-fields oneof) 'list))))
    (with-gensyms (obj)
      `(progn
         ;; DEFSTRUCT form.
         (declaim (inline ,hidden-constructor-name))
         (defstruct (,proto-type (:constructor ,hidden-constructor-name)
                                 (:include base-message)
                                 ;; Yet more class->struct code we have to add,
                                 ;; todo(jgodbout):delete asap
                                 (:predicate nil))
           ,@(remove nil
              (append
               (mapcar (lambda (slot)
                        (let ((name (field-data-internal-slot-name slot))
                              (type (field-data-type slot))
                              (initform (field-data-initform slot)))
                          (unless (eq type 'boolean)
                            `(,name ,(get-default-form type initform) :type ,type))))
                       slots)
               (mapcar (lambda (oneof)
                         (let ((name (oneof-descriptor-internal-name oneof)))
                           `(,name (make-oneof) :type oneof)))
                       oneofs))))
         ;; Define public accessors for fields.
         ,@(mapcan (lambda (field public-slot-name)
                     (make-structure-class-forms-non-lazy proto-type
                                                          field
                                                          public-slot-name))
                   non-lazy-fields public-non-lazy-slot-names)
         ,@(mapcan (lambda (field public-slot-name)
                     (make-structure-class-forms-lazy proto-type field public-slot-name))
                   lazy-fields public-lazy-slot-names)

         ;; Define public accessors for oneofs.
         ,@(mapcan (lambda (oneof)
                     (make-oneof-accessor-forms proto-type oneof))
                   oneofs)

         ;; Define public constructor.
         (declaim (inline ,public-constructor-name))
         (defun ,public-constructor-name
             (&key
              ,@(loop for sn in public-non-lazy-slot-names
                      collect `(,sn :%unset))
              ,@(loop for sn in public-lazy-slot-names
                      collect `(,sn :%unset))
              ,@(loop for oneof in oneofs
                      collect`(,(oneof-descriptor-external-name oneof) :%unset))
              ,@(loop for field in oneof-fields
                      collect `(,(proto-external-field-name field) :%unset)))
           (let ((,obj (,hidden-constructor-name)))
             ,@(mapcan
                (lambda (field)
                  (let* ((type (proto-set-type field))
                         (public-slot-name (proto-external-field-name field))
                         (set-check (if (eq type 'cl:boolean)
                                        `(eq ,public-slot-name :%unset)
                                        `(or (eq ,public-slot-name :%unset)
                                             (not ,public-slot-name)))))
                    (let ((public-accessor-name
                            (proto-slot-function-name proto-type public-slot-name :get)))
                      `((unless ,set-check
                          (setf (,public-accessor-name ,obj) ,public-slot-name))))))
                (append non-lazy-fields
                        lazy-fields
                        oneof-fields))
             ,@(mapcan
                (lambda (oneof)
                  (let* ((public-slot-name (oneof-descriptor-external-name oneof))
                         (hidden-slot-name (oneof-descriptor-internal-name oneof))
                         (set-check `(or (eq ,public-slot-name :%unset)
                                         (not ,public-slot-name))))
                         `((unless ,set-check
                             (setf (slot-value ,obj ',hidden-slot-name) ,public-slot-name)))))
                oneofs)
             ,obj))

         ;; Define clear functions.
         (defun ,clear-is-set-name (,obj)
           (setf (,is-set-name ,obj) ,is-set-init))

         (export '(,public-constructor-name ,is-set-name))
         (defmethod clear ((,obj ,proto-type))
           ,@(mapcan (lambda (name)
                       (let ((clear-name (fintern "~A.CLEAR-~A" proto-type name)))
                         `((,clear-name ,obj))))
                     (append public-non-lazy-slot-names additional-slots
                             (mapcar #'oneof-descriptor-external-name oneofs))))))))

(defun non-repeated-bool-field (field)
  "Determine if a field given by a FIELD is a non-repeated boolean."
  (and (member 'cl:boolean field)
       (not (member :repeated field))))

(defmacro define-message (type (&key name conc-name alias-for options
                                documentation)
                          &body fields &environment env)
  "Define a message named 'type' and by default a corresponding Lisp class.
   'name' can be used to override the defaultly generated Protobufs message name.
   The body consists of fields, or 'define-enum' or 'define-message' forms.
   'conc-name' will be used as the prefix to the Lisp slot accessors, if it's supplied.
   If 'alias-for' is given, no Lisp class is defined. Instead, the message will be
   used as an alias for a class that already exists in Lisp. This feature is intended
   to be used to define messages that will be serialized from existing Lisp classes;
   unless you get the slot names or readers exactly right for each field, it will be
   the case that trying to (de)serialize into a Lisp object won't work.
   'options' is a set of keyword/value pairs, both of which are strings.

   The form for fields is documented in process-field."
  (let* ((name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (conc-name (conc-name-for-type type conc-name))
         (msg-desc (make-instance 'message-descriptor
                                  :class type
                                  :name  name
                                  :qualified-name (make-qualified-name
                                                   (or *current-message-descriptor*
                                                       *current-file-descriptor*)
                                                   name)
                                  :alias-for alias-for
                                  :conc-name conc-name
                                  :options   (remove-options options "default" "packed")
                                  :documentation documentation))
         (field-offset 0)
         (top-level-form-p (null *current-message-descriptor*))
         (*current-message-descriptor* msg-desc)
         (bool-count (count-if #'non-repeated-bool-field fields))
         (bool-index -1)
         (bool-values (make-array bool-count :element-type 'bit :initial-element 0)))
    (with-collectors ((slots collect-slot)
                      (forms collect-form)
                      ;; The typedef needs to be first in forms otherwise ccl warns.
                      ;; We'll collect them separately and splice them in first.
                      (type-forms collect-type-form)
                      (lazy-fields collect-lazy-field)
                      (non-lazy-fields collect-non-lazy-field)
                      (oneofs collect-oneof))
      (dolist (field fields)
        (case (car field)
          ((define-enum)
           (let ((result (macroexpand-1 field env)))
             (assert (eq (car result) 'progn) ()
                     "The macroexpansion for ~S failed" field)))
          ((define-message define-extend)
           (let ((result (macroexpand-1 field env)))
             (assert (eq (car result) 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-type-form (cdr result))))
          ((define-extension define-group define-map)
           (destructuring-bind (&optional progn model-type model definers extra-field extra-slot)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form definers)
             (case model-type
               ((define-group define-map)
                (when extra-slot
                  (collect-slot extra-slot))
                (setf (proto-field-offset extra-field) field-offset)
                (incf field-offset)
                (collect-non-lazy-field extra-field)
                (push extra-field (proto-fields msg-desc)))
               ((define-extension)
                (push model (proto-extensions msg-desc))))))
          ((define-oneof)
           (destructuring-bind (&optional progn oneof-desc)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed in DEFINE-MESSAGE" field)
             (when oneof-desc
               (push oneof-desc (proto-oneofs msg-desc))
               (collect-oneof oneof-desc))))
          (otherwise
           (multiple-value-bind (field slot idx offset-p)
               (process-field field :conc-name conc-name
                                    :alias-for alias-for
                                    :field-offset field-offset
                                    :bool-index
                                    (when (non-repeated-bool-field field)
                                      (incf bool-index))
                                    :bool-values bool-values)
             (declare (ignore idx))
             (when offset-p
               (incf field-offset))
             (if (proto-lazy-p field)
                 (collect-lazy-field field)
                 (collect-non-lazy-field field))
             (assert (not (find-field msg-desc (proto-index field))) ()
                     "The field ~S overlaps with another field in ~S"
                     ;; TODO(cgay): this should probably refer to the external field name but I'll
                     ;; wait since I've no idea if that slot is bound at this point.
                     (proto-internal-field-name field) (proto-class msg-desc))
             (when slot
               (collect-slot slot))
             (push field (proto-fields msg-desc))))))
      ;; Not required, but this will have the proto-fields serialized
      ;; in the order they were defined.
      (setf (proto-fields msg-desc) (nreverse (proto-fields msg-desc)))
      ;; One extra slot for the make-message-with-bytes feature.
      (collect-slot
       (make-field-data
        :internal-slot-name 'proto-impl::%bytes
        :external-slot-name 'proto-impl::%bytes
        :type '(or null (simple-array (unsigned-byte 8)))
        :initarg :%bytes
        :initform nil))

      (unless (= bool-index -1)
        (collect-slot
         (make-field-data
          :internal-slot-name 'proto-impl::%%bool-values
          :external-slot-name 'proto-impl::%%bool-values
          :type `(bit-vector ,bool-count)
          :initarg :%%bool-values
          :initform `(make-array ,bool-count :element-type 'bit
                                             :initial-contents ,bool-values))))

      ;; todo(jgodbout): Storing the is-set vector as N >= 1 slots of
      ;; type sb-ext:word rather than 1 slot as a bit-vector would reduce
      ;; the memory reads by 1 per slot access.
      (collect-slot
       (make-field-data
        :internal-slot-name 'proto-impl::%%is-set
        :external-slot-name 'proto-impl::%%is-set
        :type `(bit-vector ,field-offset)
        :initarg :%%is-set
        :initform `(make-array ,field-offset
                               :element-type 'bit
                               :initial-element 0)))
      (if alias-for
          ;; If we've got an alias, define a type that is the subtype of the Lisp class so that
          ;; typep and subtypep work.  Unless alias-for is a type which is not yet defined (as is
          ;; usually the case), in which case just define a vacuous type for the message.
          (unless (or (eq type alias-for) (find-class type nil))
            (let* ((alias-class (find-class alias-for nil))
                   (alias-type (or (and alias-class (class-name alias-class))
                                   t)))
              (collect-type-form `(deftype ,type () ',alias-type))
              (collect-form `(record-protobuf-object ',alias-for ,msg-desc :message))))
          ;; If no alias, define the class now
          (collect-type-form
           (make-structure-class-forms type slots non-lazy-fields lazy-fields oneofs)))
      ;; Register it by the full symbol name.
      (record-protobuf-object type msg-desc :message)
      (collect-form `(record-protobuf-object ',type ,msg-desc :message))
      (create-progn-with-enum-forms-if-top-level top-level-form-p type-forms forms))))

(defun conc-name-for-type (type conc-name)
  (and conc-name
       (typecase conc-name
         ((member t) (format nil "~:@(~A~)-" type))
         ((or string symbol) (string-upcase (string conc-name)))
         (t nil))))

(defmacro define-extension (from to)
  "Define an extension range within a message.
   The \"body\" is the start and end of the range, both inclusive."
  (let ((to (etypecase to
              (integer to)
              (symbol (if (string-equal to "MAX") #.(1- (ash 1 29)) to)))))
    `(progn
       define-extension
       ,(make-instance 'extension-descriptor
                       :from from
                       :to   (if (eq to 'max) #.(1- (ash 1 29)) to))
       ())))

(defmacro define-extend (type (&key name conc-name options documentation)
                         &body fields &environment env)
  "Define an extension to the message named 'type'.
   'name' can be used to override the defaultly generated Protobufs message name.
   The body consists only  of fields.
   'options' is a set of keyword/value pairs, both of which are strings.

   Fields take the form (slot &key index type name default reader)
   'slot' is  a symbol giving the field name.
   'index' is the index of the field in the proto.
   'type' is the type of the slot.
   'name' can be used to override the defaultly generated Protobufs field name.
   'default' is the default value for the slot.
   'reader' is a Lisp slot reader function to use to get the value, instead of
   using 'slot-value'; this is often used when aliasing an existing class.
   'writer' is a Lisp slot writer function to use to set the value."
  (let* ((name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (message   (find-message type))
         (conc-name (or (conc-name-for-type type conc-name)
                        (and message (proto-conc-name message))))
         (alias-for (and message (proto-alias-for message)))
         (extends (and message
                       (make-instance
                        'message-descriptor
                        :class  (proto-class message)
                        :name   (proto-name message)
                        :qualified-name (proto-qualified-name message)
                        :alias-for alias-for
                        :conc-name conc-name
                        :fields   (copy-list (proto-fields message))
                        :extensions (copy-list (proto-extensions message))
                        :options  (remove-options
                                   (or options (copy-list (proto-options message)))
                                   "default" "packed")
                        :message-type :extends ; this message is an extension
                        :documentation documentation)))
         (top-level-form-p (null *current-message-descriptor*))
         ;; Only now can we bind *current-message-descriptor* to the new extended message
         (*current-message-descriptor* extends))
    (assert message ()
            "There is no message named ~A to extend" name)
    (assert (eq type (proto-class message)) ()
            "The type ~S doesn't match the type of the message being extended ~S"
            type message)
    (with-collectors ((forms collect-form))
      (dolist (field fields)
        (assert (not (member (car field)
                             '(define-enum define-message define-extend define-extension)))
                () "The body of ~S can only contain field and group definitions" 'define-extend)
        (case (car field)
          ((define-group)
           (destructuring-bind (&optional progn model-type model definers extra-field extra-slot)
               (macroexpand-1 field env)
             (declare (ignore model))
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form definers)
             (case model-type
               ((define-group)
                (when extra-slot
                  ;;--- Refactor to get rid of all this duplicated code!
                  (let* ((sname  (field-data-internal-slot-name extra-slot))
                         ;; The field name
                         (fname (field-data-external-slot-name extra-slot))
                         (stable (fintern "~A-VALUES" sname))
                         (stype (field-data-type extra-slot))
                         (reader (or (field-data-accessor extra-slot)
                                     (if conc-name
                                         (fintern "~A~A" conc-name sname)
                                         (symbol-name sname))))
                         (writer (fintern "~A-~A" 'set reader))
                         (default (field-data-initform extra-slot)))
                    (collect-form `(without-redefinition-warnings ()
                                     (let ((,stable (tg:make-weak-hash-table
                                                     :weakness :key :test #'eq)))
                                       ,@(and reader `((defmethod ,reader ((object ,type))
                                                         (gethash object ,stable ,default))))
                                       ,@(and writer `((defmethod ,writer ((object ,type) value)
                                                         (declare (type ,stype value))
                                                         (setf (gethash object ,stable) value))))
                                       ;; For Python compatibility
                                       (defmethod get-extension ((object ,type)
                                                                 (slot (eql ',fname)))
                                         (values (gethash object ,stable ,default)))
                                       ;; Set and has need to be defined for sname and fname
                                       ;; for usefulness to reader and serialization
                                       (defmethod set-extension ((object ,type)
                                                                 (slot (eql ',sname))
                                                                 value)
                                         (setf (gethash object ,stable) value))
                                       (defmethod set-extension ((object ,type)
                                                                 (slot (eql ',fname))
                                                                 value)
                                         (setf (gethash object ,stable) value))
                                       (defmethod has-extension ((object ,type)
                                                                 (slot (eql ',fname)))
                                         (multiple-value-bind (value foundp)
                                             (gethash object ,stable)
                                           (declare (ignore value))
                                           foundp))
                                       (defmethod has-extension ((object ,type)
                                                                 (slot (eql ',sname)))
                                         (multiple-value-bind (value foundp)
                                             (gethash object ,stable)
                                           (declare (ignore value))
                                           foundp))
                                       (defmethod clear-extension ((object ,type)
                                                                   (slot (eql ',fname)))
                                         (remhash object ,stable))
                                       (defmethod (setf ,reader)
                                           (val (object ,type))
                                         (,writer object val)))))))
                (setf (proto-message-type extra-field) :extends)        ;this field is an extension
                (appendf (proto-fields extends) (list extra-field))
                (appendf (proto-extended-fields extends) (list extra-field))))))
          (otherwise
           (multiple-value-bind (field slot idx)
               (process-field field :conc-name conc-name :alias-for alias-for)
             (assert (index-within-extensions-p idx message) ()
                     "The index ~D is not in range for extending ~S"
                     idx (proto-class message))
             (when slot
               (let* (;; The slot name which is the %field-name
                      (sname  (field-data-internal-slot-name slot))
                      ;; The field name
                      (fname (field-data-external-slot-name slot))
                      (stable (fintern "~A-VALUES" sname))
                      (stype (field-data-type slot))
                      (reader (or (field-data-accessor slot)
                                  (if conc-name
                                      (fintern "~A~A" conc-name sname)
                                      (symbol-name sname))))
                      (writer (fintern "~A-~A" 'set reader))
                      (default (field-data-initform slot)))
                 ;; For the extended slots, each slot gets its own table
                 ;; keyed by the object, which lets us avoid having a slot in each
                 ;; instance that holds a table keyed by the slot name
                 ;; Multiple 'define-extends' on the same class in the same image
                 ;; will result in harmless redefinitions, so squelch the warnings
                 ;;--- Maybe these methods need to be defined in 'define-message'?
                 (collect-form
                  `(without-redefinition-warnings ()
                     (let ((,stable (tg:make-weak-hash-table :weakness :key :test #'eq)))
                       ,@(and reader `((defmethod ,reader ((object ,type))
                                         (gethash object ,stable ,default))))
                       ,@(and writer `((defmethod ,writer ((object ,type) value)
                                         (declare (type ,stype value))
                                         (setf (gethash object ,stable) value))))
                       (defmethod get-extension ((object ,type) (slot (eql ',fname)))
                         (values (gethash object ,stable ,default)))
                       ;; Set and has need to be defined for sname and fname
                       ;; for usefulness to reader and serialization
                       (defmethod set-extension ((object ,type) (slot (eql ',sname)) value)
                         (setf (gethash object ,stable) value))
                       (defmethod set-extension ((object ,type) (slot (eql ',fname)) value)
                         (setf (gethash object ,stable) value))
                       (defmethod has-extension ((object ,type) (slot (eql ',fname)))
                         (multiple-value-bind (value foundp)
                             (gethash object ,stable)
                           (declare (ignore value))
                           foundp))
                       (defmethod has-extension ((object ,type) (slot (eql ',sname)))
                         (multiple-value-bind (value foundp)
                             (gethash object ,stable)
                           (declare (ignore value))
                           foundp))
                       (defmethod clear-extension ((object ,type) (slot (eql ',fname)))
                         (remhash object ,stable))
                       (defmethod (setf ,reader)
                           (val (object ,type))
                         (,writer object val)))))
                 ;; This so that (de)serialization works
                 (setf (proto-reader field) reader
                       (proto-writer field) writer)))
             (setf (proto-message-type field) :extends)         ;this field is an extension
             (appendf (proto-fields extends) (list field))
             (appendf (proto-extended-fields extends) (list field))))))
      (collect-form `(record-protobuf-object ',type ,extends :message))
      (create-progn-with-enum-forms-if-top-level top-level-form-p forms))))

(defun index-within-extensions-p (index message)
  (let ((extensions (proto-extensions message)))
    (some #'(lambda (ext)
              (and (i>= index (proto-extension-from ext))
                   (i<= index (proto-extension-to ext))))
          extensions)))

(defmacro define-group (type (&key index label name conc-name alias-for reader options
                                   documentation)
                        &body fields &environment env)
  "Define a message named 'type' and a Lisp 'defclass', *and* a field named type.
   This is deprecated in Protobufs, but if you have to use it, you must give
   'index' as the field index and 'label' of :required, :optional or :repeated.
   'name' can be used to override the defaultly generated Protobufs message name.
   The body consists of fields, or 'define-enum' or 'define-message' forms.
   'conc-name' will be used as the prefix to the Lisp slot accessors, if it's supplied.
   If 'alias-for' is given, no Lisp class is defined. Instead, the message will be
   used as an alias for a class that already exists in Lisp. This feature is intended
   to be used to define messages that will be serialized from existing Lisp classes;
   unless you get the slot names or readers exactly right for each field, it will be
   the case that trying to (de)serialize into a Lisp object won't work.
   'options' is a set of keyword/value pairs, both of which are strings.

   Fields take the form (slot &key index type name default reader)
   'slot' is a symbol giving the field name
   'index' is the index of the field in the group.
   'type' is the type of the slot.
   'name' can be used to override the defaultly generated Protobufs field name.
   'default' is the default value for the slot.
   'reader' is a Lisp slot reader function to use to get the value, instead of
   using 'slot-value'; this is often used when aliasing an existing class.
   'writer' is a Lisp slot writer function to use to set the value."
  (check-type index integer)
  (check-type label (member :required :optional :repeated))
  (let* ((slot    (or type (and name (proto->slot-name name *package*))))
         (name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (conc-name (conc-name-for-type type conc-name))
         (reader  (or reader
                      (let ((msg-conc (proto-conc-name *current-message-descriptor*)))
                        (and msg-conc
                             (fintern "~A~A" msg-conc slot)))))
         (internal-slot-name (fintern "%~A" slot))
         (mslot   (unless alias-for
                    (make-field-data
                           :internal-slot-name internal-slot-name
                           :external-slot-name slot
                           :type
                           (case label
                             (:required `(or ,type null))
                             (:optional `(or ,type null))
                             (:repeated `(list-of ,type)))
                           :initform nil
                           :accessor reader
                           :initarg (kintern (symbol-name slot)))))
         (mfield  (make-instance 'field-descriptor
                    :name  (slot-name->proto slot)
                    :type  name
                    :class type
                    :qualified-name (make-qualified-name *current-message-descriptor*
                                                         (slot-name->proto slot))
                    :set-type type
                    :label label
                    :index index
                    :internal-field-name internal-slot-name
                    :external-field-name slot
                    :reader reader
                    :message-type :group))
         (message (make-instance 'message-descriptor
                    :class type
                    :name  name
                    :qualified-name (make-qualified-name *current-message-descriptor* name)
                    :alias-for alias-for
                    :conc-name conc-name
                    :options   (remove-options options "default" "packed")
                    :message-type :group                ;this message is a group
                    :documentation documentation))
         (field-offset 0)
         (bool-count (count-if #'non-repeated-bool-field fields))
         (bool-index -1)
         (bool-values (make-array bool-count :element-type 'bit :initial-element 0))
         ;; Only now can we bind *current-message-descriptor* to the (group) message.
         (*current-message-descriptor* message))
    (with-collectors ((slots collect-slot)
                      (forms collect-form)
                      ;; The typedef needs to be first in forms otherwise ccl warns.
                      ;; We'll collect them separately and splice them in first.
                      (type-forms collect-type-form)
                      (lazy-fields collect-lazy-field)
                      (non-lazy-fields collect-non-lazy-field)
                      (oneofs collect-oneof))
      (dolist (field fields)
        (case (car field)
          ((define-enum define-message define-extend)
           (let ((result (macroexpand-1 field env)))
             (assert (eq (car result) 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form (cdr result))))
          ((define-extension define-group define-map)
           (destructuring-bind (&optional progn model-type model definers extra-field extra-slot)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-type-form definers)
             (case model-type
               ((define-group define-map)
                (setf (proto-field-offset extra-field) field-offset)
                (incf field-offset)
                (collect-non-lazy-field extra-field)
                (when extra-slot
                  (collect-slot extra-slot))
                (appendf (proto-fields message) (list extra-field)))
               ((define-extension)
                (appendf (proto-extensions message) (list model))))))
          ((define-oneof)
           (destructuring-bind (&optional progn oneof-desc)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (when oneof-desc
               (appendf (proto-oneofs message) (list oneof-desc))
               (collect-oneof oneof-desc))))
          (otherwise
           (multiple-value-bind (field slot idx offset-p)
               (process-field field :conc-name conc-name
                                    :alias-for alias-for
                                    :field-offset field-offset
                                    :bool-index
                                    (when (non-repeated-bool-field field)
                                      (incf bool-index))
                                    :bool-values bool-values)
             (declare (ignore idx))
             (when offset-p
               (incf field-offset))
             (if (proto-lazy-p field)
                 (collect-lazy-field field)
                 (collect-non-lazy-field field))
             (assert (not (find-field message (proto-index field))) ()
                     "The field ~S overlaps with another field in ~S"
                     (proto-internal-field-name field) (proto-class message))
             (when slot
               (collect-slot slot))
             (appendf (proto-fields message) (list field))))))
      ;; todo(jgodbout): Storing the is-set vector as N >= 1 slots of
      ;; type sb-ext:word rather than 1 slot as a bit-vector would reduce
      ;; the memory reads by 1 per slot access.
      (collect-slot
       (make-field-data
          :internal-slot-name 'proto-impl::%%is-set
          :external-slot-name 'proto-impl::%%is-set
          :type `(bit-vector ,field-offset)
          :initarg :%%is-set
          :initform `(make-array ,field-offset
                                 :element-type 'bit
                                 :initial-element 0)))

      (unless (= bool-index -1)
        (collect-slot
         (make-field-data
          :internal-slot-name 'proto-impl::%%bool-values
          :external-slot-name 'proto-impl::%%bool-values
          :type `(bit-vector ,bool-count)
          :initarg :%%bool-values
          :initform `(make-array ,bool-count :element-type 'bit
                                             :initial-contents ,bool-values))))

      (if alias-for
        ;; If we've got an alias, define a a type that is the subtype of
        ;; the Lisp class that typep and subtypep work
        (unless (or (eq type alias-for) (find-class type nil))
          (collect-type-form `(deftype ,type () ',alias-for)))
          (collect-type-form
           (make-structure-class-forms type slots non-lazy-fields lazy-fields oneofs)))
      (collect-form `(record-protobuf-object ',type ,message :message))
      ;; Group can never be a top level element.
      `(progn
         define-group
         ,message
         (
          ,@type-forms
          ,@forms)
         ,mfield
         ,mslot))))

(defun process-field (field &key conc-name alias-for field-offset bool-index bool-values)
  "Process one field descriptor within 'define-message' or 'define-extend'.
Returns a 'proto-field' object, a CLOS slot form, the field index, and a boolean which
indicates if FIELD has an offset.

Arguments
  FIELD: The description of the field as laid out in the proto schema.
  CONC-NAME: The name to concatenate to the beginning of the field accessor.
  ALIAS-FOR is to determine if this is an alias for a difference field.
  FIELD-OFFSET is an internal concept of the index of a field
    in a proto-message.
  BOOL-INDEX: nil if this is not a simple (non-repeated) boolean field.
    If this is a simple boolean field, this is the index into the bit vector of all
    simple boolean fields (i.e., the bool-values argument).
  BOOL-VALUES: A bit-vector holding all boolean values for a message.
    On exit this vector holds the correct default value for FIELD if it is a
    simple boolean field."
  ;; Slot is a symbol giving the field name
  ;; Type is the lisp type specified in a defstruct field or defclass slot.
  ;; Typename is the name of the type from the .proto file.
  ;; Name can be used to override the defaultly generated Protobufs field name.
  ;; Index is the index of the field in the proto.
  ;; Default is the default value for the slot.
  ;; Packed determines if the field is a packed field with respect to proto api.
  ;; Lazy determines whether to lazily deserialize a field with respect to proto api.
  ;; Label is a member of (:repeated :vector), (:repeated :list),
  ;;   (:optional), (:required).
  ;; Documentation is any documentation that has been set for the slot.
  (destructuring-bind (slot &key type typename name (default nil default-p) packed lazy
                            index label documentation &allow-other-keys)
      field
    (let* (;; Public accessors and setters for slots should be defined later.
           (internal-slot-name (fintern "%~A" slot))
           (reader (and conc-name
                        (fintern "~A~A" conc-name slot))))
      (multiple-value-bind (ptype pclass packed-p enum-values root-lisp-type)
          ;; The protobuf returned by clos-type-to-protobuf-type may be incorrect due to
          ;; camel-case shenanigans.  Prefer typename, if available.
          (clos-type-to-protobuf-type type)
        (declare (ignore packed-p enum-values))
        (assert index)
        (multiple-value-bind (label repeated-type) (values-list label)
          ;; Proto3 optional fields are known as 'singular' fields, and are handled differently.
          (let* ((label (if (and (eq (proto-syntax *current-file-descriptor*) :proto3)
                                 (eq label :optional))
                            :singular
                            label))
                 ;; Singular fields do not have offsets, as they don't have has-* functions.
                 (offset (and (not (eq label :singular)) field-offset))
                 (default
                  (cond ((and (eq label :repeated)
                              (eq repeated-type :vector))
                         $empty-vector)
                        ((eq label :repeated)
                         $empty-list)
                        (default-p default)
                        (t $empty-default)))
                 (cslot (unless alias-for
                          (make-field-data
                           :internal-slot-name internal-slot-name
                           :external-slot-name slot
                           :type `,type
                           :accessor reader
                           :initarg (kintern (symbol-name slot))
                           :initform
                           (cond ((eq label :repeated)
                                     ;; Repeated fields get a container for their elements
                                     (if (eq repeated-type :vector)
                                         `(make-array 5 :fill-pointer 0 :adjustable t)
                                         nil))
                                 ((and (not default-p)
                                          (eq label :optional)
                                          ;; Use unbound for booleans only
                                          (not (eq pclass :bool)))
                                  nil)
                                 (default-p `,default)))))
                 (field (make-instance
                         'field-descriptor
                         :name  (or name (slot-name->proto slot))
                         :type  (or typename ptype)
                         :lisp-type (when root-lisp-type (qualified-symbol-name root-lisp-type))
                         :set-type type
                         :class pclass
                         :qualified-name (make-qualified-name *current-message-descriptor*
                                                              (or name (slot-name->proto slot)))
                         :label label
                         :index  index
                         :field-offset offset
                         :internal-field-name internal-slot-name
                         :external-field-name slot
                         :reader reader
                         :default default
                         ;; Pack the field only if requested and it actually makes sense
                         :packed  (and (eq label :repeated) packed t)
                         :lazy (and lazy t)
                         :bool-index bool-index
                         :documentation documentation)))
            (when (and bool-index default (not (eq default $empty-default)))
              (setf (bit bool-values bool-index) 1))
            (values field cslot index (and offset t))))))))

(defparameter *rpc-package* nil
  "The Lisp package that implements RPC.
   This should be set when an RPC package that uses CL-Protobufs gets loaded.")
(defparameter *rpc-call-function* nil
  "The Lisp function that implements RPC client-side calls.
   This should be set when an RPC package that uses CL-Protobufs gets loaded.")

(defmacro define-service (type (&key name options
                                documentation source-location)
                          &body method-specs)
  "Define a service named TYPE and a generic function for each method.
   NAME can be used to override the defaultly generated service name.
   OPTIONS is a set of keyword/value pairs, both of which are strings.
   DOCUMENTATION is an optional description of the service (a string).
   SOURCE-LOCATION is an optional source location.

   The body is a set of METHOD-SPECS of the form (name (input-type [=>] output-type) &key options).
   INPUT-TYPE and OUTPUT-TYPE may also be of the form (type &key name)."
  (let* ((name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect
                        (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (service (make-instance 'service-descriptor
                                 :class type
                                 :name  name
                                 :qualified-name (make-qualified-name *current-file-descriptor*
                                                                      name)
                                 :options options
                                 :documentation documentation
                                 :source-location source-location))
         (index 0))
    (with-collectors ((forms collect-form))
      (dolist (method method-specs)
        (destructuring-bind (function (&rest types)
                             &key name options documentation)
            method
          (let* ((input-type   (first types))
                 (output-type  (if (string= (string (second types)) "=>")
                                   (third types)
                                   (second types)))
                 (streams-type (if (string= (string (second types)) "=>")
                                   (getf (cdddr types) :streams)
                                   (getf (cddr  types) :streams)))
                 (input-name (and (listp input-type)
                                  (getf (cdr input-type) :name)))
                 (input-streaming (and (listp input-type)
                                       (getf (cdr input-type) :stream)))
                 (input-type (if (listp input-type) (car input-type) input-type))
                 (qual-input-type (make-qualified-name *current-file-descriptor*
                                                       (class-name->proto input-type)))
                 (output-name (and (listp output-type)
                                   (getf (cdr output-type) :name)))
                 (output-streaming (and (listp output-type)
                                        (getf (cdr output-type) :stream)))
                 (output-type (if (listp output-type) (car output-type) output-type))
                 (qual-output-type (make-qualified-name *current-file-descriptor*
                                                        (class-name->proto output-type)))
                 (streams-name (and (listp streams-type)
                                    (getf (cdr streams-type) :name)))
                 (streams-type (if (listp streams-type) (car streams-type) streams-type))
                 (options (loop for (key val) on options by #'cddr
                                collect (make-option
                                         (if (symbolp key)
                                             (slot-name->proto key)
                                             key)
                                         val)))
                 (package (let ((name (strcat (package-name *package*) "-RPC")))
                            (or (find-package name)
                                (make-package name :use '()))))
                 (client-fn (intern (nstring-upcase (format nil "CALL-~A" function)) package))
                 (server-fn (intern (nstring-upcase (format nil "~A-IMPL" function)) package))
                 (method  (make-instance
                           'method-descriptor
                           :class function
                           :name  (or name (class-name->proto function))
                           :qualified-name (make-qualified-name *current-file-descriptor*
                                                                (or name
                                                                    (class-name->proto function)))
                           :service-name (proto-impl::proto-name service)
                           :client-stub client-fn
                           :server-stub server-fn
                           :input-type  input-type
                           :input-name  (or input-name qual-input-type)
                           :input-streaming input-streaming
                           :output-type output-type
                           :output-name (or output-name qual-output-type)
                           :output-streaming output-streaming
                           :streams-type streams-type
                           :streams-name (and streams-type
                                              (or streams-name (class-name->proto streams-type)))
                           :index (iincf index)
                           :options options
                           :documentation documentation)))
            (appendf (proto-methods service) (list method))
            ;; The following are the hooks to an RPC implementation
            (let* ((vrequest  (intern "REQUEST" package))
                   (vresponse (intern "RESPONSE" package))
                   (vchannel  (intern "CHANNEL" package))
                   (vcallback (intern "CALLBACK" package))
                   (vrpc      (intern "RPC" package)))
              ;; The client side stub, e.g., 'read-air-reservation'.
              ;; The expectation is that the RPC implementation will provide code to make it
              ;; easy to implement a method for this on each kind of channel (HTTP, TCP socket,
              ;; IPC, etc). Unlike C++/Java/Python, we don't need a client-side subclass,
              ;; because we can just use multi-methods.
              ;; The 'do-XXX' method calls the RPC code with the channel, the method
              ;; (i.e., a 'method-descriptor' object), the request and the callback function.
              ;; The RPC code should take care of serializing the input, transmitting the
              ;; request over the wire, waiting for input (or not, if it's asynchronous),
              ;; filling in the output, and either returning the response (if synchronous)
              ;; or calling the callback with the response as an argument (if asynchronous).
              ;; It will also deserialize the response so that the client code sees the
              ;; response as an application object.
              (collect-form
               `(defgeneric ,client-fn (,vchannel ,vrequest &key ,vcallback ,vresponse)
                  ,@(and documentation `((:documentation ,documentation)))
                  #+(or ccl)
                  (declare (values ,output-type))
                  (:method (,vchannel ,vrequest &key ,vcallback ,vresponse)
                    (declare (ignorable ,vchannel ,vcallback))
                    (let ((call (and *rpc-package* *rpc-call-function*)))
                      (assert call ()
                              "There is no RPC package loaded!")
                      (funcall call ,vchannel ',method ,vrequest ,vresponse
                               :callback ,vcallback
                                        ; :type ',input-type
                               )))))
              ;; The server side stub, e.g., 'do-read-air-reservation'.
              ;; The expectation is that the server-side program will implement
              ;; a method with the business logic for this on each kind of channel
              ;; (HTTP, TCP socket, IPC, etc), possibly on a server-side subclass
              ;; of the input class.
              ;; The business logic is expected to perform the correct operations on
              ;; the input object, which arrived via Protobufs, and produce an output
              ;; of the given type, which will be serialized and sent back over the wire.
              ;; The channel objects hold client identity information, deadline info,
              ;; etc, and can be side-effected to indicate success or failure.
              ;; The RPC code provides the channel classes and does (de)serialization, etc.
              ;; The VRPC argument is always of type RPC2:SERVER-RPC.
              (collect-form `(defgeneric ,server-fn (,vchannel ,vrequest ,vrpc)
                               ,@(and documentation `((:documentation ,documentation)))
                               #+(or ccl)
                               (declare (values ,output-type))))))))
      (collect-form `(appendf (proto-services *current-file-descriptor*) (list ,service)))
      `(progn ,@forms))))
