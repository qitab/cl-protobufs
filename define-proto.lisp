;;; Copyright 2012-2020 Google LLC
;;;
;;; Use of this source code is governed by an MIT-style
;;; license that can be found in the LICENSE file or at
;;; https://opensource.org/licenses/MIT.

(in-package "PROTO-IMPL")


;;; Protocol buffer defining macros


#|
Notes on macroexpansion:

The lisp generated proto file should look like:

-------------------------------

;; In a package named "cl-protobufs.<the-.proto-package-name>"

(proto:define-message color-wheel1
    (:conc-name "")
  ;; Nested messages.
  (proto:define-message color-wheel1.metadata1
      (:conc-name "")
    ;; Fields.
    (author  :index 1  :type cl:string :label (:optional) :typename "string")
    (revision  :index 2  :type cl:string :label (:optional) :typename "string")
    (date  :index 3  :type cl:string :label (:optional) :typename "string"))
  ;; Fields.
  (name  :index 1  :type cl:string :label (:required) :typename "string")
  (colors  :index 2  :type (proto:list-of color1) :label (:repeated :list)
           :typename "Color1")
  (metadata  :index 3  :type (cl:or cl:null color-wheel1.metadata1)
             :label (:optional) :typename "Metadata1"))

(cl:setf (cl:gethash #P"third_party/lisp/cl_protobufs/tests/serialization-test.proto"
                     proto-impl::*all-schemas*)
         (proto:find-schema 'serialization-test))

(export ...)
-------------------------------

The define-schema form sets up the schema object and stores it in the
*protobuf* global variable . The schema object will hold the protobuf-service
object(s) that gets generated by the define-service macro.
TODO(jgodbout): Remove all schema.

Next we get into the define-* macro's.

The possible top level define macros are:
- define-enum
- define-message
- define-extend
- define-service
- define-type-alias

Inside of those macros there may also be define-* macros:
- define-enum
- define-message
- define-group
- define-extension
- define-extend
- define-service
- define-type-alias

The most common define-* macros we will see are the macros that
define messages, which generate PROTOBUF-MESSAGE classes and
create the message structures that hold data. These are:
- define-message
- define-group
- define-extend

DEFINE-ENUM:

The define-enum macro creates a PROTOBUF-ENUM meta-object as well
as a type with enum-name being (MEMBER :enum-1 :enum-2 ...).
It also creates methods to access the default-enum, and convert
from the enum keyword to the enum index and back.

DEFINE-EXTENSION:

The define-extension macro defines a PROTOBUF-EXTENSION meta-object and
set it in a PROTOBUF-MESSAGE meta-object.

This meta-object details the possible range indices of proto extensions
allowed in a protobuf message.

DEFINE-EXTEND:

The define-extend macro creates a PROTOBUF-MESSAGE meta-object that
overrides a PROTOBUF-MESSAGE meta-object created in define-message or
define-group. The new meta-object will be identical to the original
but with extra fields.

We return forms to create this meta-object as well as accessors and
setters for the new fields.

DEFINE-MESSAGE DEFINE-GROUP:

The define-message and define-group macros work much the same way.
They take the type (message name) and a list of sub-elements which
may include define-message, define-group, define-extension, define-extend,
define-enum, or a field which is just a declaration of the field object in a proto.

Example:   (author  :index 1  :type cl:string :label (:optional) :typename "string")

First we create the PROTOBUF-MESSAGE meta-object that is define in the define-message
lambda list and set it in the *protobuf* global.
If we see a define-message or define-group we recursively call the define macro
to create a subgroup which will be named:
  top-level-message.submessage1.submessage2
We save the resultant forms that are output as so define-message or define-group
may output them at the and of the macro-call.

If we see a define-enum, define-message, or define-extend macro
we save the resultant form to a list of forms to output.

If we see a define-group form we call it and it creates a message just like
define-message. The only difference is a group acts as a field in a message
as well as being an message type in the message, so we must add a field to the
PROTOBUF-MESSAGE meta-object as if it were a field.

If we see a field we call process-field which creates a PROTOBUF-FIELD meta-object
containing  details of the field and returns a form to create this meta-object.
We save the form for both output and future processing.

Next we call MAKE-STRUCTURE-CLASS-FORMS that takes the field meta-objects
and creates forms for creating defstruct form for the proto data container
that will be used in client code. This is where the accessors, setters, and has
functions are defined. It outputs all of the forms to create these objects.

Finally we output all of the created forms.

DEFINE-SERVICE:

The define-service macro creates forms that make the PROTOBUF-SERVICE
meta-object, add it to the PROTOBUF-SCHEMA meta-object, and create
method stubs for the service implementation.

Note: Actually using services require a gRPC plugin.

DEFINE-TYPE-ALIAS:

The define-type-alias macro creates a PROTOBUF-TYPE-ALIAS meta-object
and a deftype form so we can use a alias a lisp type outside of cl-protobufs
instead of a protobuf-implementation type.

e.g.:
(proto:define-type-alias date ()
      :lisp-type integer
      :proto-type string
      :serializer integer-to-date
      :deserializer date-to-integer)
|#

;; TODO(jgodbout): remove this, we already have protobuf-field
(defstruct field-data
  "Keep field metadata for making the structure object."
  (internal-slot-name nil :type symbol)
  (external-slot-name nil :type symbol)
  (accessor nil)
  (type nil)
  (initarg nil)
  (initform nil))

(defvar *protobuf* nil
  "The current proto-schema, proto-message, or group object we're compiling.")

(defun define-schema (type &key name syntax package lisp-package import
                           optimize options documentation)
  "Define a schema named TYPE, corresponding to a .proto file of that name.
   NAME can be used to override the defaultly generated Protobufs name.
   SYNTAX and PACKAGE are as they would be in a .proto file.
   LISP-PACKAGE can be used to specify a Lisp package if it is different from
   the Protobufs package given by 'package'.
   IMPORT is a list of pathname strings to be imported.
   OPTIMIZE can be either :space (the default) or :speed; if it is :speed, the
   serialization code will be much faster, but much less compact.
   OPTIONS is a property list, i.e., (\"key1\" \"val1\" \"key2\" \"val2\" ...).
   DOCUMENTATION is the documentation for the proto."
  (let* ((name     (or name (class-name->proto type)))
         (package  (and package (if (stringp package)
                                    package
                                    (string-downcase (string package)))))
         (lisp-pkg (and lisp-package (if (stringp lisp-package)
                                         lisp-package
                                         (string lisp-package))))
         (options  (remove-options
                    (loop for (key val) on options by #'cddr
                          collect (make-option
                                   (if (symbolp key)
                                       (slot-name->proto key)
                                       key)
                                   val))
                    "optimize_for" "lisp_package"))
         (imports  (if (listp import) import (list import)))
         (schema   (make-instance
                    'file-descriptor
                    :class    type
                    :name     name
                    :syntax   (or syntax "proto2")
                    :package  package
                    :lisp-package (cond ((and lisp-pkg (find-proto-package lisp-pkg))
                                         (package-name (find-proto-package lisp-pkg)))
                                        (lisp-pkg)
                                        (t (substitute #\- #\_ package)))
                    :real-lisp-package *protobuf-package*
                    :imports  imports
                    :options  (if optimize
                                  (append options
                                          (list (make-option
                                                 "optimize_for"
                                                 (if (eq optimize :speed)
                                                     "SPEED"
                                                     "CODE_SIZE")
                                                 'symbol)))
                                  options)
                    :documentation documentation)))
    (record-schema schema)
    (setf *protobuf* schema
          *protobuf-rpc-package*
          (or (find-proto-package
               (format nil "~A-~A" lisp-pkg 'rpc))
              *package*)
          *protobuf-package* (or (find-proto-package lisp-pkg) *package*))
    (process-imports schema imports)))

(defmacro with-proto-source-location ((type name definition-type
                                       &optional pathname start-pos end-pos)
                                      &body body)
  "Establish a context which causes the generated Lisp code to have
   source location information that points to the .proto file.
   'type' is the name of the Lisp definition (a symbol).
   'name' is the name of the Protobufs definition (a string).
   'definition-type' is the kind of definition, e.g., 'protobuf-enum'.
   'pathname', 'start-pos' and 'end-pos' give the location of the definition
   in the .proto file."
  `(progn
     (record-proto-source-location ',type ,name ',definition-type
                                   ,pathname ,start-pos ,end-pos)
     ,@body))

#+ccl
(defun record-proto-source-location (type name definition-type
                                     &optional pathname start-pos end-pos)
  (declare (ignore name))
  (when (and ccl::*record-source-file*
             (typep pathname '(or string pathname)))
    (let ((ccl::*loading-toplevel-location* (ccl::make-source-note :filename  pathname
                                                                   :start-pos start-pos
                                                                   :end-pos   end-pos)))
      (ccl:record-source-file type definition-type))))

#-(or ccl)
(defun record-proto-source-location (type name definition-type
                                     &optional pathname start-pos end-pos)
  (declare (ignorable name type definition-type pathname start-pos end-pos)))

(defun %make-enum->numeral-table (enum-values)
  "Makes a hash table mapping enum values to numerals.
ENUM-VALUES is a list of PROTOBUF-ENUM-VALUEs."
  `(case enum
     ,@(loop for v in enum-values
             collect
             `(,(protobuf-enum-value-value v) ,(protobuf-enum-value-index v)))))

(defun %make-numeral->enum-table (enum-values)
  "Makes a hash table mapping enum values to numerals.
ENUM-VALUES is a list of PROTOBUF-ENUM-VALUEs."
  `(case numeral
     ,@(loop with mapped = (make-hash-table)
             for v in enum-values
             for proto-index = (protobuf-enum-value-index v)
             for already-set-p = (gethash proto-index mapped)
             unless already-set-p
               do
          (setf (gethash proto-index mapped) t)
             unless already-set-p
               collect
             `(,proto-index ,(protobuf-enum-value-value v)))))

(deftype numeral () "byte 32" '(signed-byte 32))

(defgeneric cl-protobufs:numeral->enum (enum numeral &optional default)
  (:documentation
   "Converts a NUMERAL to a corresponding ENUM keyword.
ENUM is a Lisp symbol name of the ENUM.
DEFAULT the default value if NUMERAL in not contained in the ENUM."))

(deftype quoted-symbol () "(quote sym)" '(cons (eql quote) (cons symbol)))

(defgeneric cl-protobufs:enum->numeral (enum keyword &optional default)
  (:documentation
   "Converts an ENUM keyword to a corresponding ENUM KEYWORD.
ENUM is a Lisp symbol name of the ENUM.
DEFAULT the default value if KEYWORD is a not contained in ENUM."))

(defun make-enum<->numeral-forms (type enum-values)
  "Generates forms for enum<->numeral conversion functions.
TYPE is the enum type name.  ENUM-VALUES is a list of PROTOBUF-ENUM-VALUEs."
  (let ((enum->numeral (intern (format nil "~A->NUMERAL" type) *protobuf-package*))
        (numeral->enum (intern (format nil "NUMERAL->~A" type) *protobuf-package*)))
    `(progn
       (defun ,enum->numeral (enum &optional default)
         (declare (symbol enum))
         (let ((numeral ,(%make-enum->numeral-table enum-values)))
           (if numeral numeral default)))

       (defun ,numeral->enum (numeral &optional default)
         (declare (numeral numeral))
         (let ((enum ,(%make-numeral->enum-table enum-values)))
           (if enum enum default)))

       (setf (get ',type 'numeral->enum) ',numeral->enum)
       (setf (get ',type 'enum->numeral) ',enum->numeral)

       (defmethod cl-protobufs:enum->numeral
           ((e (eql ',type)) keyword &optional default)
         (,enum->numeral keyword default))
       (defmethod cl-protobufs:numeral->enum
           ((e (eql ',type)) numeral &optional default)
         (,numeral->enum numeral default)))))

(defgeneric enum-default-value (enum-type)
  (:documentation
   "Get the default enum value for ENUM-TYPE"))

(defmethod enum-default-value (enum-type)
  "If no default enum value function can be found for a specific ENUM-TYPE
return nil."
  nil)

(defun make-enum-default (type enum-values)
  "Generate a function to return the default enum value for
an enum of type TYPE. The default type should be the enum
with the lowest index value in ENUM-VALUES."
  (let ((default-value))
    (loop with smallest-index = nil
          for enum in enum-values
          when (or (not smallest-index)
                   (< (protobuf-enum-value-index enum) smallest-index))
            do
       (setf smallest-index (protobuf-enum-value-index enum)
             default-value (protobuf-enum-value-value enum)))
    `(defmethod enum-default-value ((e (eql ',type)))
       ,default-value)))

(defun make-enum-constant-forms (type enum-values)
  "Generates forms for defining a constant for each enum value in ENUM-VALUES.
TYPE is the enum type name.  ENUM-VALUES is a list of PROTOBUF-ENUM-VALUEs.

Constant names are in the form of +<message_name>.<value_name>+ when the enum is defined in a
message, and of +<value_name>+ when the enum is defined at top-level."
  (let* ((enum-name (symbol-name type))
         (dot (position #\. enum-name :test #'char= :from-end t))
         ;; Use C/C++ enum scope.
         (scope (and dot (subseq enum-name 0 dot)))
         (*package* *protobuf-package*)
         (constants
          (loop for v in enum-values
                for c = (intern (format nil "+~@[~A.~]~A+" scope
                                        (protobuf-enum-value-value v)))
                collect `(defconstant ,c ,(protobuf-enum-value-index v)))))
    `(progn
       ,@constants
       (export ',(mapcar #'second constants) ,*protobuf-package*))))

(defun enum-values (enum-type)
  "Returns all keyword values that belong to the given ENUM-TYPE."
  (let ((expansion (type-expand enum-type)))
    (check-type expansion (cons (eql member) list))
    (rest expansion)))

(defmacro define-enum (type (&key name conc-name alias-for source-location)
                       &body values)
  "Define a lisp type given the data for a protobuf enum type.
Also generates conversion functions between enum values and numerals.  Function names are
<enum_name>->NUMERAL and NUMERAL-><enum_name>, respectively.
Both accept an optional default argument.

Parameters:
  TYPE: The name of the type.
  NAME: Override for the protobuf enum type name.
  CONC-NAME: Prefix to the defaultly generated protobuf enum name.
  ALIAS-FOR: Make this enum an alias for another enum.
  SOURCE-LOCATION: The location of the source code for this define-enum.
  VALUES: The possible values for the enum in the form (name :index index)."
  (let* ((name    (or name (class-name->proto type)))
         (conc-name (conc-name-for-type type conc-name))
         (enum  (make-protobuf-enum
                  :class  type
                  :name   name
                  :alias-for (if (listp alias-for)
                                 alias-for
                                 (list alias-for)))))
    (with-collectors ((vals  collect-val)
                      (forms collect-form)
                      (enum-values collect-enum-value))
      ;; The middle value is :index, useful for readability of generated code...
      (loop for (name nil index) in values do
        (let* ((val-name  (kintern (if conc-name
                                       (format nil "~A~A" conc-name name)
                                       (symbol-name name))))
               (enum-val  (make-protobuf-enum-value
                            :index  index
                            :value  val-name)))
          (collect-val val-name)
          (collect-enum-value enum-val)))
      (setf (protobuf-enum-values enum) enum-values)
      (cond ((and alias-for (not (eq type alias-for)))
             ;; If we've got an alias, define a a type that is the subtype of
             ;; the Lisp enum so that typep and subtypep work
             (collect-form `(deftype ,type () ',alias-for)))
            ((null alias-for)
             ;; If no alias, define the Lisp enum type now
             (collect-form `(deftype ,type () '(member ,@vals)))
             (collect-form (make-enum<->numeral-forms type enum-values))
             (collect-form (make-enum-constant-forms type enum-values))
             (collect-form (make-enum-default type enum-values))))
      (collect-form `(record-protobuf-object ',type ,enum :enum))
      ;; Register it by the full symbol name.
      (record-protobuf-object type enum :enum)
      (if source-location
          `(progn (with-proto-source-location (,type ,name protobuf-enum ,@source-location)
                    ,@forms))
          `(progn ,@forms)))))

(declaim (inline proto-%bytes))
(defun proto-%bytes (obj)
  "Returns the %bytes field of the proto object OBJ."
  (slot-value obj '%bytes))

(declaim (inline (setf proto-%bytes)))
(defun (setf proto-%bytes) (new-value obj)
  "Sets the %bytes field of the proto object OBJ with NEW-VALUE."
  (setf (slot-value obj '%bytes) new-value))

(defun make-lazy-reader-form (proto-type field lazy-reader)
  "Makes the form for a reader of a lazy field.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  FIELD: The field definition of the lazy field.
  LAZY-READER: The reader name of the lazy field."
  (let ((slot-name (proto-internal-field-name field))
        (field-type (proto-class field))
        (repeated (eq (proto-label field) :repeated))
        (vectorp (vector-field-p field)))
    (with-gensyms (obj field-obj bytes)
      `(defmethod ,lazy-reader :around ((,obj ,proto-type))
         ,(if (not repeated)
              `(let* ((,field-obj (call-next-method))
                      (,bytes (proto-%bytes ,field-obj)))
                 (if ,bytes
                     ;; Re-create the field object by deserializing its %bytes field.
                     (setf (slot-value ,obj ',slot-name)
                           (%deserialize-object ',field-type ,bytes nil nil))
                     ,field-obj))
              `(let ((,field-obj (call-next-method)))
                 (if (notany #'proto-%bytes ,field-obj)
                     ,field-obj
                     ,(with-gensyms (maybe-deserialize-object field-element)
                        `(flet ((,maybe-deserialize-object (,field-element)
                                  (let ((,bytes (proto-%bytes ,field-element)))
                                    (if ,bytes
                                        ;; Re-create the field object by deserializing its %bytes
                                        ;; field.
                                        (%deserialize-object ',field-type ,bytes nil nil)
                                        ,field-element))))
                           (setf (slot-value ,obj ',slot-name)
                                 ,(if vectorp
                                      `(map 'vector #',maybe-deserialize-object
                                            (the vector ,field-obj))
                                      `(mapcar #',maybe-deserialize-object ,field-obj))))))))))))

;; As a compile time performance improvement we should see
;; how big the hash table usually is.
(defparameter *proto-function-table* (make-hash-table)
  "Hash table mapping proto-type to a hash-table whose keys are
field names and values are the field function.")

(defun set-functions-in-hash-table (proto-type field-name)
  "Add a hash-table to *proto-function-table* for PROTO-TYPE if it does
not already exist, then add the field functions to the map from FIELD-NAME
in the found hash-table."
  (multiple-value-bind (value present)
      (gethash proto-type *proto-function-table* (make-hash-table))
    (when (not present)
      (setf (gethash proto-type *proto-function-table*) value))
    (setf (gethash field-name value)
          (list (proto-slot-function-name proto-type field-name :has)
                (proto-slot-function-name proto-type field-name :get)
                (proto-slot-function-name proto-type field-name :clear)))))


(defun make-common-forms-for-structure-class (proto-type public-slot-name slot-name field)
  "Create the common forms needed for all message fields
has, is-set, clear, set.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix).
  SLOT-NAME: Slot name for the field (with the #\% prefix).
  FIELD: The class object field definition of the field."
  (let ((public-accessor-name (proto-slot-function-name proto-type public-slot-name :get))
        (is-set-accessor (intern (format nil "~A-%%IS-SET" proto-type)
                                 *protobuf-package*))
        (hidden-accessor-name (intern (format nil "~A-~A" proto-type slot-name)
                                      *protobuf-package*))
        (has-function-name (proto-slot-function-name proto-type public-slot-name :has))
        (default-form (get-default-form (proto-set-type field)
                                        (proto-default field)))
        (index (proto-field-offset field))
        (clear-function-name (proto-slot-function-name proto-type public-slot-name :clear))
        (bool-index (proto-bool-index field))
        (bit-field-name (intern (format nil "~A-%%BOOL-VALUES" proto-type)
                                *protobuf-package*)))

    (with-gensyms (obj new-value)
      `(
        (declaim (inline (setf ,public-accessor-name)))
        (defun (setf ,public-accessor-name) (,new-value ,obj)
          (setf (bit (,is-set-accessor ,obj) ,index) 1)
          ,(if bool-index
               `(setf (bit (,bit-field-name ,obj) ,bool-index)
                      (if ,new-value 1 0))
               `(setf (,hidden-accessor-name ,obj) ,new-value)))

        (declaim (inline ,has-function-name))
        (defun ,has-function-name (,obj)
          (= (bit (,is-set-accessor ,obj) ,index) 1))

        ;; Clear function
        (declaim (inline ,clear-function-name))
        (defun ,clear-function-name (,obj)
          ,(if bool-index
               `(setf (bit (,bit-field-name ,obj) ,bool-index)
                      ,(if default-form 1 0))
               `(setf (,hidden-accessor-name ,obj) ,default-form))
          (setf (bit (,is-set-accessor ,obj) ,index) 0))

        ;; Create defmethods to allow for getting/setting compatibly
        ;; with the standard-classes.
        (defmethod ,public-slot-name ((,obj ,proto-type))
          (,public-accessor-name ,obj))

        (defmethod (setf ,public-slot-name) (,new-value (,obj ,proto-type))
          (setf (,public-accessor-name ,obj) ,new-value))

        ;; This must be done outside of proto generation
        ;; since we reset the hash-table after every  protobuf macro-expansion.
        ;; Also, for proto-type public-slot-name to have a collison
        ;; we would need two protos in the same package with the same
        ;; field, this is impossible.
        (proto-impl::set-functions-in-hash-table ',proto-type ',public-slot-name)

        (export '(,has-function-name ,clear-function-name ,public-accessor-name)
                ,*protobuf-package*)))))

(defun make-structure-class-forms-lazy (proto-type field public-slot-name)
  "Makes forms for the lazy fields of a proto message using STRUCTURE-CLASS.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  FIELD: The field definition for which to define accessors.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix)."
  (let* ((slot-name (proto-internal-field-name field))
         (repeated (eq (proto-label field) :repeated))
         (vectorp (vector-field-p field))
         (public-accessor-name (proto-slot-function-name proto-type public-slot-name :get))
         (hidden-accessor-name (intern (format nil "~A-~A" proto-type slot-name)
                                       *protobuf-package*)))
    (with-gensyms (obj field-obj bytes)
      `(
        ;; Public reader.
        (declaim (inline ,public-accessor-name))
        (defun ,public-accessor-name (,obj)
          ,(if (not repeated)
               `(let* ((,field-obj (,hidden-accessor-name ,obj))
                       (,bytes (proto-%bytes ,field-obj)))
                  (if ,bytes
                      (setf (,hidden-accessor-name ,obj)
                            ;; Re-create the field object by deserializing its %bytes
                            ;; field.
                            (%deserialize-object ',(proto-class field) ,bytes nil nil))
                      ,field-obj))
               `(let ((,field-obj (,hidden-accessor-name ,obj)))
                  (if (notany #'proto-%bytes ,field-obj)
                      ,field-obj
                      ,(with-gensyms (maybe-deserialize-object field-element)
                         `(flet ((,maybe-deserialize-object (,field-element)
                                   (let ((,bytes (proto-%bytes ,field-element)))
                                     (if ,bytes
                                         ;; Re-create the field object by deserializing
                                         ;; its %bytes field.
                                         (%deserialize-object ',(proto-class field) ,bytes nil nil)
                                         ,field-element))))
                            (setf (,hidden-accessor-name ,obj)
                                  ,(if vectorp
                                       `(map 'vector #',maybe-deserialize-object
                                             (the vector ,field-obj))
                                       `(mapcar #',maybe-deserialize-object ,field-obj)))))))))
        ,@(make-common-forms-for-structure-class proto-type public-slot-name slot-name field)))))

(defun make-structure-class-forms-non-lazy (proto-type field public-slot-name)
  "Makes forms for the non-lazy fields of a proto message.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  FIELD: The field definition for which to define accessors.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix)."
  (let* ((slot-name (proto-internal-field-name field))
         (public-accessor-name (proto-slot-function-name proto-type public-slot-name :get))
         (hidden-accessor-name (intern (format nil "~A-~A" proto-type slot-name)
                                       *protobuf-package*))
         (bool-index (proto-bool-index field))
         (bit-field-name (intern (format nil "~A-%%BOOL-VALUES" proto-type)
                                 *protobuf-package*)))

    (with-gensyms (obj)
      `((declaim (inline ,public-accessor-name))
        (defun ,public-accessor-name (,obj)
          ,(if bool-index
               `(plusp (bit (,bit-field-name ,obj) ,bool-index))
               `(,hidden-accessor-name ,obj)))

        ,@(make-common-forms-for-structure-class
           proto-type public-slot-name slot-name field)))))


(let ((default-form (make-hash-table)))
  (setf (gethash 'cl:double-float default-form) 0.0d0)
  (setf (gethash 'cl:float default-form) 0.0)
  (setf (gethash 'proto:int64 default-form)
        (coerce 0 'proto:int64))
  (setf (gethash 'proto:uint64 default-form)
        (coerce 0 'proto:uint64))
  (setf (gethash 'proto:int32 default-form)
        (coerce 0 'proto:int32))
  (setf (gethash 'proto:fixed64 default-form)
        (coerce 0 'proto:fixed64))
  (setf (gethash 'proto:fixed32 default-form)
        (coerce 0 'proto:fixed32))
  (setf (gethash 'proto:sfixed64 default-form)
        (coerce 0 'proto:sfixed64))
  (setf (gethash 'proto:sfixed32 default-form)
        (coerce 0 'proto:sfixed32))
  (setf (gethash 'cl:boolean default-form) nil)
  (setf (gethash 'cl:string default-form) "")
  (setf (gethash 'proto:byte-vector default-form)
        '(make-byte-vector 0 :adjustable t))
  (setf (gethash 'proto:uint32 default-form)
        (coerce 0 'proto:uint32))
  (setf (gethash 'proto:sint32 default-form)
        (coerce 0 'proto:sint32))
  (setf (gethash 'proto:sint64 default-form)
        (coerce 0 'proto:sint64))
  ;; One of the "Home grown types..."
  (setf (gethash 'cl:keyword default-form)
        :default-keyword)
  (defun get-default-form (type default)
    "Get the default value for TYPE and the proto set DEFAULT"
    (let ((possible-default (gethash type default-form)))
      (cond
        ((not (member default
                      (list $empty-vector $empty-list $empty-default nil)))
         default)
        ((or possible-default
             (eq type 'cl:boolean))
         possible-default)
        ((and (listp type)
              (eq (first type) 'cl-protobufs:vector-of))
         '(make-array 0 :adjustable t))
        ((and (listp type)
              (eq (first type) 'cl-protobufs:list-of))
         nil)
        ((and (listp type)
              (eq (first type) 'cl:or)
              (eq (second type) 'cl:null))
         nil)
        ;; The only possibility left is we have an enum.
        ((enum-default-value `,type) (enum-default-value `,type))
        (t `(enum-default-value ',type))))))

(defun make-structure-class-forms (proto-type slots non-lazy-fields lazy-fields)
  "Makes the definition forms for the define-group and define-message macros.

Arguments:
  PROTO-TYPE: The Lisp type name of the proto message.
  SLOTS: Slot definitions created by PROCESS-FIELD.
  NON-LAZY-FIELDS: Field definitions for non-lazy fields.
  LAZY-FIELDS: Field definitions for lazy fields."
  (let* ((public-constructor-name
          (intern (format nil "MAKE-~A" proto-type) *protobuf-package*))
         (hidden-constructor-name
          (intern (format nil "%MAKE-~A" proto-type) *protobuf-package*))
         (public-lazy-slot-names (mapcar #'proto-external-field-name lazy-fields))
         (public-non-lazy-slot-names (mapcar #'proto-external-field-name non-lazy-fields))
         (is-set-name (intern (format nil "~A-%%IS-SET" proto-type) *protobuf-package*))
         (clear-is-set-name
          (intern (format nil "~A.CLEAR-%%IS-SET" proto-type)
                  *protobuf-package*))
         (is-set-init (field-data-initform
                       (find-if #'(lambda (el)
                                    (eq (field-data-internal-slot-name el) '%%is-set))
                                slots)))
         (additional-slots '(%%is-set)))
    (with-gensyms (obj)
      `(progn
         ;; DEFSTRUCT form.
         (declaim (inline ,hidden-constructor-name))
         (defstruct (,proto-type (:constructor ,hidden-constructor-name)
                                 (:include base-message)
                                 ;; Yet more class->struct code we have to add,
                                 ;; todo(jgodbout):delete asap
                                 (:predicate nil))
           ,@(remove nil
              (mapcar (lambda (slot)
                        (let ((name (field-data-internal-slot-name slot))
                              (type (field-data-type slot))
                              (initform (field-data-initform slot)))
                          (unless (eq type 'boolean)
                            `(,name ,(get-default-form type initform) :type ,type))))
                      slots)))
         ;; Define public accessors for fields.
         ,@(mapcan (lambda (field public-slot-name)
                     (make-structure-class-forms-non-lazy proto-type
                                                          field
                                                          public-slot-name))
                   non-lazy-fields public-non-lazy-slot-names)
         ,@(mapcan (lambda (field public-slot-name)
                     (make-structure-class-forms-lazy proto-type field public-slot-name))
                   lazy-fields public-lazy-slot-names)

         ;; Define public constructor.
         (declaim (inline ,public-constructor-name))
         (defun ,public-constructor-name
             (&key
              ,@(loop for sn in public-non-lazy-slot-names
                      collect `(,sn :%unset))
              ,@(loop for sn in public-lazy-slot-names
                      collect `(,sn :%unset)))
           (let ((,obj (,hidden-constructor-name)))
             ,@(mapcan
                (lambda (slot)
                  (let* ((name (field-data-internal-slot-name slot))
                         (type (field-data-type slot))
                         (public-slot-name (field-data-external-slot-name slot))
                         (set-check (if (eq type 'cl:boolean)
                                        `(eq ,public-slot-name :%unset)
                                        `(or (eq ,public-slot-name :%unset)
                                             (not ,public-slot-name)))))
                    (unless (or (eq name '%%is-set) (eq name '%bytes) (eq name '%%bool-values))
                      (let* ((public-accessor-name
                              (proto-slot-function-name proto-type public-slot-name :get)))
                        `((unless ,set-check
                            (setf (,public-accessor-name ,obj) ,public-slot-name)))))))
                slots)
             ,obj))

         ;; Define clear functions.
         (defun ,clear-is-set-name (,obj)
           (setf (,is-set-name ,obj) ,is-set-init))

         (export '(,public-constructor-name ,is-set-name) ,*protobuf-package*)
         (defmethod clear ((,obj ,proto-type))
           ,@(mapcan (lambda (name)
                       (let ((clear-name (intern (format nil "~A.CLEAR-~A" proto-type name)
                                                 *protobuf-package*)))
                         `((,clear-name ,obj))))
                     (append public-non-lazy-slot-names additional-slots)))))))

(defun non-repeated-bool-field (field)
  "Determine if a field given by a FIELD is a non-repeated boolean."
  (and (member 'cl:boolean field)
       (not (member :repeated field))))

(defmacro define-message (type (&key name conc-name alias-for options
                                documentation source-location)
                          &body fields &environment env)
  "Define a message named 'type' and by default a corresponding Lisp class.
   'name' can be used to override the defaultly generated Protobufs message name.
   The body consists of fields, or 'define-enum' or 'define-message' forms.
   'conc-name' will be used as the prefix to the Lisp slot accessors, if it's supplied.
   If 'alias-for' is given, no Lisp class is defined. Instead, the message will be
   used as an alias for a class that already exists in Lisp. This feature is intended
   to be used to define messages that will be serialized from existing Lisp classes;
   unless you get the slot names or readers exactly right for each field, it will be
   the case that trying to (de)serialize into a Lisp object won't work.
   'options' is a set of keyword/value pairs, both of which are strings.

   The form for fields is documented in process-field."
  (let* ((name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (conc-name (conc-name-for-type type conc-name))
         (msg-desc (make-instance 'message-descriptor
                                  :class type
                                  :name  name
                                  :qualified-name (make-qualified-name *protobuf* name)
                                  :parent *protobuf*
                                  :alias-for alias-for
                                  :conc-name conc-name
                                  :options   (remove-options options "default" "packed")
                                  :documentation documentation
                                  :source-location source-location))
         (index 0)
         (field-offset 0)
         (proto-parent *protobuf*)
         (*protobuf* msg-desc)
         (bool-count (count-if #'non-repeated-bool-field fields))
         (bool-index -1)
         (bool-values (make-array bool-count :element-type 'bit :initial-element 0)))

    (with-collectors ((slots collect-slot)
                      (forms collect-form)
                      ;; The typedef needs to be first in forms otherwise ccl warns.
                      ;; We'll collect them separately and splice them in first.
                      (type-forms collect-type-form)
                      (lazy-fields collect-lazy-field)
                      (non-lazy-fields collect-non-lazy-field))
      (dolist (field fields)
        (case (car field)
          ((define-enum define-message define-extend)
           (let ((result (macroexpand-1 field env)))
             (assert (eq (car result) 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form (cdr result))))
          ((define-extension define-group)
           (destructuring-bind (&optional progn model-type model definers extra-field extra-slot)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form definers)
             (case model-type
               ((define-group)
                (setf (proto-parent model) msg-desc)
                (when extra-slot
                  (collect-slot extra-slot))
                (setf (proto-field-offset extra-field) field-offset)
                (incf field-offset)
                (collect-non-lazy-field extra-field)
                (push extra-field (proto-fields msg-desc)))
               ((define-extension)
                (push model (proto-extensions msg-desc))))))
          (otherwise
           (multiple-value-bind (field slot idx lazy-reader)
               (process-field field :conc-name conc-name
                                    :alias-for alias-for
                                    :field-offset field-offset
                                    :bool-index
                                    (when (non-repeated-bool-field field)
                                      (incf bool-index))
                                    :bool-values bool-values)
             (incf field-offset)
             (if (proto-lazy-p field)
                 (collect-lazy-field field)
                 (collect-non-lazy-field field))
             (assert (not (find-field msg-desc (proto-index field))) ()
                     "The field ~S overlaps with another field in ~S"
                     ;; TODO(cgay): this should probably refer to the external field name but I'll
                     ;; wait since I've no idea if that slot is bound at this point.
                     (proto-internal-field-name field) (proto-class msg-desc))
             (setq index idx)
             (when slot
               (collect-slot slot))
             (push field (proto-fields msg-desc))
             (when lazy-reader
               (collect-form (make-lazy-reader-form type field lazy-reader)))))))
      ;; Not required, but this will have the proto-fields serialized
      ;; in the order they were defined.
      (setf (proto-fields msg-desc) (nreverse (proto-fields msg-desc)))
      ;; One extra slot for the deserialize-object-to-bytes feature
      (collect-slot
       (make-field-data
        :internal-slot-name 'proto-impl::%bytes
        :external-slot-name 'proto-impl::%bytes
        :type '(or null (simple-array (unsigned-byte 8)))
        :initarg :%bytes
        :initform nil))

      (unless (= bool-index -1)
        (collect-slot
         (make-field-data
          :internal-slot-name 'proto-impl::%%bool-values
          :external-slot-name 'proto-impl::%%bool-values
          :type `(bit-vector ,bool-count)
          :initarg :%%bool-values
          :initform `(make-array ,bool-count :element-type 'bit
                                             :initial-contents ,bool-values))))

      ;; todo(jgodbout): Storing the is-set vector as N >= 1 slots of
      ;; type sb-ext:word rather than 1 slot as a bit-vector would reduce
      ;; the memory reads by 1 per slot access.
      (collect-slot
       (make-field-data
        :internal-slot-name 'proto-impl::%%is-set
        :external-slot-name 'proto-impl::%%is-set
        :type `(bit-vector ,(length fields))
        :initarg :%%is-set
        :initform `(make-array ,(length fields) :element-type 'bit
                                                :initial-element 0)))
      (if alias-for
          ;; If we've got an alias, define a type that is the subtype of the Lisp class so that
          ;; typep and subtypep work.  Unless alias-for is a type which is not yet defined (as is
          ;; usually the case), in which case just define a vacuous type for the message.
          (unless (or (eq type alias-for) (find-class type nil))
            (let* ((alias-class (find-class alias-for nil))
                   (alias-type (or (and alias-class (class-name alias-class))
                                   t)))
              (collect-type-form `(deftype ,type () ',alias-type))
              (collect-form `(record-protobuf-object ',alias-for ,msg-desc :message))))
          ;; If no alias, define the class now
          (collect-type-form
           (make-structure-class-forms type slots non-lazy-fields lazy-fields)))
      ;; Register it by the full symbol name.
      (record-protobuf-object type msg-desc :message)
      ;; Add its parent
      (setf (proto-parent msg-desc) proto-parent)
      (collect-form `(record-protobuf-object ',type ,msg-desc :message))
      (let ((common-form
             `(progn
                ,@type-forms
                ,@forms
                (setf (proto-parent ,msg-desc) ,proto-parent))))
        `(progn
           ,(if source-location
                `(progn
                   (with-proto-source-location (,type ,name message-descriptor ,@source-location)
                     ,common-form))
                `,common-form))))))

(defun conc-name-for-type (type conc-name)
  (and conc-name
       (typecase conc-name
         ((member t) (format nil "~:@(~A~)-" type))
         ((or string symbol) (string-upcase (string conc-name)))
         (t nil))))

(defmacro define-extension (from to)
  "Define an extension range within a message.
   The \"body\" is the start and end of the range, both inclusive."
  (let ((to (etypecase to
              (integer to)
              (symbol (if (string-equal to "MAX") #.(1- (ash 1 29)) to)))))
    `(progn
       define-extension
       ,(make-instance 'protobuf-extension
          :from from
          :to   (if (eq to 'max) #.(1- (ash 1 29)) to))
       ())))

(defmacro define-extend (type (&key name conc-name options documentation)
                         &body fields &environment env)
  "Define an extension to the message named 'type'.
   'name' can be used to override the defaultly generated Protobufs message name.
   The body consists only  of fields.
   'options' is a set of keyword/value pairs, both of which are strings.

   Fields take the form (slot &key index type name default reader)
   'slot' is  a symbol giving the field name.
   'index' is the index of the field in the proto.
   'type' is the type of the slot.
   'name' can be used to override the defaultly generated Protobufs field name.
   'default' is the default value for the slot.
   'reader' is a Lisp slot reader function to use to get the value, instead of
   using 'slot-value'; this is often used when aliasing an existing class.
   'writer' is a Lisp slot writer function to use to set the value."
  (let* ((name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (message   (find-message type))
         (conc-name (or (conc-name-for-type type conc-name)
                        (and message (proto-conc-name message))))
         (alias-for (and message (proto-alias-for message)))
         (extends (and message
                       (make-instance
                        'message-descriptor
                        :class  (proto-class message)
                        :name   (proto-name message)
                        :qualified-name (proto-qualified-name message)
                        :parent *protobuf*
                        :alias-for alias-for
                        :conc-name conc-name
                        :fields   (copy-list (proto-fields message))
                        :extensions (copy-list (proto-extensions message))
                        :options  (remove-options
                                   (or options (copy-list (proto-options message)))
                                   "default" "packed")
                        :message-type :extends ; this message is an extension
                        :documentation documentation)))
         ;; Only now can we bind *protobuf* to the new extended message
         (*protobuf* extends)
         (index 0))
    (assert message ()
            "There is no message named ~A to extend" name)
    (assert (eq type (proto-class message)) ()
            "The type ~S doesn't match the type of the message being extended ~S"
            type message)
    (with-collectors ((forms collect-form))
      (dolist (field fields)
        (assert (not (member (car field)
                             '(define-enum define-message define-extend define-extension
                               define-type-alias)))
                () "The body of ~S can only contain field and group definitions" 'define-extend)
        (case (car field)
          ((define-group)
           (destructuring-bind (&optional progn model-type model definers extra-field extra-slot)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form definers)
             (case model-type
               ((define-group)
                (setf (proto-parent model) extends)
                (when extra-slot
                  ;;--- Refactor to get rid of all this duplicated code!
                  (let* ((sname  (field-data-internal-slot-name extra-slot))
                         ;; The field name
                         (fname (field-data-external-slot-name extra-slot))
                         (stable (fintern "~A-VALUES" sname))
                         (stype (field-data-type extra-slot))
                         (reader (or (field-data-accessor extra-slot)
                                     (intern (if conc-name
                                                 (format nil "~A~A" conc-name sname)
                                                 (symbol-name sname))
                                             *protobuf-package*)))
                         (writer (or (intern (format nil "~A-~A" 'set reader) *protobuf-package*)))
                         (default (field-data-initform extra-slot)))
                    (collect-form `(without-redefinition-warnings ()
                                     (let ((,stable (tg:make-weak-hash-table
                                                     :weakness :value :test #'eq)))
                                       ,@(and reader `((defmethod ,reader ((object ,type))
                                                         (gethash object ,stable ,default))))
                                       ,@(and writer `((defmethod ,writer ((object ,type) value)
                                                         (declare (type ,stype value))
                                                         (setf (gethash object ,stable) value))))
                                       ;; For Python compatibility
                                       (defmethod get-extension ((object ,type)
                                                                 (slot (eql ',fname)))
                                         (values (gethash object ,stable ,default)))
                                       ;; Set and has need to be defined for sname and fname
                                       ;; for usefulness to reader and serialization
                                       (defmethod set-extension ((object ,type)
                                                                 (slot (eql ',sname))
                                                                 value)
                                         (setf (gethash object ,stable) value))
                                       (defmethod set-extension ((object ,type)
                                                                 (slot (eql ',fname))
                                                                 value)
                                         (setf (gethash object ,stable) value))
                                       (defmethod has-extension ((object ,type)
                                                                 (slot (eql ',fname)))
                                         (multiple-value-bind (value foundp)
                                             (gethash object ,stable)
                                           (declare (ignore value))
                                           foundp))
                                       (defmethod has-extension ((object ,type)
                                                                 (slot (eql ',sname)))
                                         (multiple-value-bind (value foundp)
                                             (gethash object ,stable)
                                           (declare (ignore value))
                                           foundp))
                                       (defmethod clear-extension ((object ,type)
                                                                   (slot (eql ',fname)))
                                         (remhash object ,stable))
                                       (defmethod (setf ,reader)
                                           (val (object ,type))
                                         (,writer object val)))))))
                (setf (proto-message-type extra-field) :extends)        ;this field is an extension
                (appendf (proto-fields extends) (list extra-field))
                (appendf (proto-extended-fields extends) (list extra-field))))))
          (otherwise
           (multiple-value-bind (field slot idx)
               (process-field field :conc-name conc-name :alias-for alias-for)
             ;; (assert (not (find-field extends (proto-index field))) ()
             ;;         "The field ~S overlaps with another field in ~S"
             ;;         (proto-value field) (proto-class extends))
             (assert (index-within-extensions-p idx message) ()
                     "The index ~D is not in range for extending ~S"
                     idx (proto-class message))
             (setq index idx)
             (when slot
               (let* (;; The slot name which is the %field-name
                      (sname  (field-data-internal-slot-name slot))
                      ;; The field name
                      (fname (field-data-external-slot-name slot))
                      (stable (fintern "~A-VALUES" sname))
                      (stype (field-data-type slot))
                      (reader (or (field-data-accessor slot)
                                  (intern (if conc-name
                                              (format nil "~A~A" conc-name sname)
                                              (symbol-name sname))
                                          *protobuf-package*)))
                      (writer (or (intern (format nil "~A-~A" 'set reader) *protobuf-package*)))
                      (default (field-data-initform slot)))
                 ;; For the extended slots, each slot gets its own table
                 ;; keyed by the object, which lets us avoid having a slot in each
                 ;; instance that holds a table keyed by the slot name
                 ;; Multiple 'define-extends' on the same class in the same image
                 ;; will result in harmless redefinitions, so squelch the warnings
                 ;;--- Maybe these methods need to be defined in 'define-message'?
                 (collect-form
                  `(without-redefinition-warnings ()
                     (let ((,stable (tg:make-weak-hash-table :weakness :value :test #'eq)))
                       ,@(and reader `((defmethod ,reader ((object ,type))
                                         (gethash object ,stable ,default))))
                       ,@(and writer `((defmethod ,writer ((object ,type) value)
                                         (declare (type ,stype value))
                                         (setf (gethash object ,stable) value))))
                       (defmethod get-extension ((object ,type) (slot (eql ',fname)))
                         (values (gethash object ,stable ,default)))
                       ;; Set and has need to be defined for sname and fname
                       ;; for usefulness to reader and serialization
                       (defmethod set-extension ((object ,type) (slot (eql ',sname)) value)
                         (setf (gethash object ,stable) value))
                       (defmethod set-extension ((object ,type) (slot (eql ',fname)) value)
                         (setf (gethash object ,stable) value))
                       (defmethod has-extension ((object ,type) (slot (eql ',fname)))
                         (multiple-value-bind (value foundp)
                             (gethash object ,stable)
                           (declare (ignore value))
                           foundp))
                       (defmethod has-extension ((object ,type) (slot (eql ',sname)))
                         (multiple-value-bind (value foundp)
                             (gethash object ,stable)
                           (declare (ignore value))
                           foundp))
                       (defmethod clear-extension ((object ,type) (slot (eql ',fname)))
                         (remhash object ,stable))
                       (defmethod (setf ,reader)
                           (val (object ,type))
                         (,writer object val)))))
                 ;; This so that (de)serialization works
                 (setf (proto-reader field) reader
                       (proto-writer field) writer)))
             (setf (proto-message-type field) :extends)         ;this field is an extension
             (appendf (proto-fields extends) (list field))
             (appendf (proto-extended-fields extends) (list field))))))
      (setf (proto-parent extends) message)
      (collect-form `(record-protobuf-object ',type ,extends :message))
      `(progn ,@forms))))

(defun index-within-extensions-p (index message)
  (let ((extensions (proto-extensions message)))
    (some #'(lambda (ext)
              (and (i>= index (proto-extension-from ext))
                   (i<= index (proto-extension-to ext))))
          extensions)))

(defmacro define-group (type (&key index label name conc-name alias-for reader options
                                   documentation source-location)
                        &body fields &environment env)
  "Define a message named 'type' and a Lisp 'defclass', *and* a field named type.
   This is deprecated in Protobufs, but if you have to use it, you must give
   'index' as the field index and 'label' of :required, :optional or :repeated.
   'name' can be used to override the defaultly generated Protobufs message name.
   The body consists of fields, or 'define-enum' or 'define-message' forms.
   'conc-name' will be used as the prefix to the Lisp slot accessors, if it's supplied.
   If 'alias-for' is given, no Lisp class is defined. Instead, the message will be
   used as an alias for a class that already exists in Lisp. This feature is intended
   to be used to define messages that will be serialized from existing Lisp classes;
   unless you get the slot names or readers exactly right for each field, it will be
   the case that trying to (de)serialize into a Lisp object won't work.
   'options' is a set of keyword/value pairs, both of which are strings.

   Fields take the form (slot &key index type name default reader)
   'slot' is a symbol giving the field name
   'index' is the index of the field in the group.
   'type' is the type of the slot.
   'name' can be used to override the defaultly generated Protobufs field name.
   'default' is the default value for the slot.
   'reader' is a Lisp slot reader function to use to get the value, instead of
   using 'slot-value'; this is often used when aliasing an existing class.
   'writer' is a Lisp slot writer function to use to set the value."
  (check-type index integer)
  (check-type label (member :required :optional :repeated))
  (let* ((slot    (or type (and name (proto->slot-name name *protobuf-package*))))
         (name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (conc-name (conc-name-for-type type conc-name))
         (reader  (or reader
                      (let ((msg-conc (proto-conc-name *protobuf*)))
                        (and msg-conc
                             (intern (format nil "~A~A" msg-conc slot) *protobuf-package*)))))
         (internal-slot-name (intern (format nil "%~A" slot) *protobuf-package*))
         (mslot   (unless alias-for
                    (make-field-data
                           :internal-slot-name internal-slot-name
                           :external-slot-name slot
                           :type
                           (case label
                             (:required `(or ,type null))
                             (:optional `(or ,type null))
                             (:repeated `(list-of ,type)))
                           :initform nil
                           :accessor reader
                           :initarg (kintern (symbol-name slot)))))
         (mfield  (make-instance 'protobuf-field
                    :name  (slot-name->proto slot)
                    :type  name
                    :class type
                    :qualified-name (make-qualified-name *protobuf* (slot-name->proto slot))
                    :parent *protobuf*
                    :set-type type
                    :label label
                    :index index
                    :internal-field-name internal-slot-name
                    :external-field-name slot
                    :reader reader
                    :message-type :group))
         (message (make-instance 'message-descriptor
                    :class type
                    :name  name
                    :qualified-name (make-qualified-name *protobuf* name)
                    :parent *protobuf*
                    :alias-for alias-for
                    :conc-name conc-name
                    :options   (remove-options options "default" "packed")
                    :message-type :group                ;this message is a group
                    :documentation documentation
                    :source-location source-location))
         (index 0)
         (field-offset 0)
         (bool-count (count-if #'non-repeated-bool-field fields))
         (bool-index -1)
         (bool-values (make-array bool-count :element-type 'bit :initial-element 0))
         ;; Only now can we bind *protobuf* to the (group) message
         (*protobuf* message))
    (with-collectors ((slots collect-slot)
                      (forms collect-form)
                      ;; The typedef needs to be first in forms otherwise ccl warns.
                      ;; We'll collect them separately and splice them in first.
                      (type-forms collect-type-form)
                      (lazy-fields collect-lazy-field)
                      (non-lazy-fields collect-non-lazy-field))
      (dolist (field fields)
        (case (car field)
          ((define-enum define-message define-extend define-type-alias)
           (let ((result (macroexpand-1 field env)))
             (assert (eq (car result) 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form (cdr result))))
          ((define-extension define-group)
           (destructuring-bind (&optional progn model-type model definers extra-field extra-slot)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form definers)
             (case model-type
               ((define-group)
                (setf (proto-parent model) message)
                (setf (proto-field-offset extra-field) field-offset)
                (incf field-offset)
                (collect-non-lazy-field extra-field)
                (when extra-slot
                  (collect-slot extra-slot))
                (appendf (proto-fields message) (list extra-field)))
               ((define-extension)
                (appendf (proto-extensions message) (list model))))))
          (otherwise
           (multiple-value-bind (field slot idx)
               (process-field field :conc-name conc-name
                                    :alias-for alias-for
                                    :field-offset field-offset
                                    :bool-index
                                    (when (non-repeated-bool-field field)
                                      (incf bool-index))
                                    :bool-values bool-values)
             (incf field-offset)
             (if (proto-lazy-p field)
                 (collect-lazy-field field)
                 (collect-non-lazy-field field))
             (assert (not (find-field message (proto-index field))) ()
                     "The field ~S overlaps with another field in ~S"
                     (proto-internal-field-name field) (proto-class message))
             (setq index idx)
             (when slot
               (collect-slot slot))
             (appendf (proto-fields message) (list field))))))
      ;; todo(jgodbout): Storing the is-set vector as N >= 1 slots of
      ;; type sb-ext:word rather than 1 slot as a bit-vector would reduce
      ;; the memory reads by 1 per slot access.
      (collect-slot
       (make-field-data
          :internal-slot-name 'proto-impl::%%is-set
          :external-slot-name 'proto-impl::%%is-set
          :type `(bit-vector ,(length fields))
          :initarg :%%is-set
          :initform `(make-array ,(length fields) :element-type 'bit
                                                  :initial-element 0)))

      (unless (= bool-index -1)
        (collect-slot
         (make-field-data
          :internal-slot-name 'proto-impl::%%bool-values
          :external-slot-name 'proto-impl::%%bool-values
          :type `(bit-vector ,bool-count)
          :initarg :%%bool-values
          :initform `(make-array ,bool-count :element-type 'bit
                                             :initial-contents ,bool-values))))

      (if alias-for
        ;; If we've got an alias, define a a type that is the subtype of
        ;; the Lisp class that typep and subtypep work
        (unless (or (eq type alias-for) (find-class type nil))
          (collect-type-form `(deftype ,type () ',alias-for)))
          (collect-type-form
           (make-structure-class-forms type slots non-lazy-fields lazy-fields)))
      (collect-form `(record-protobuf-object ',type ,message :message))
      `(progn
         define-group
         ,message
         ,(if source-location
              `((with-proto-source-location (,type ,name message-descriptor ,@source-location))
                ,@type-forms
                ,@forms)
              `(
                ,@type-forms
                ,@forms))
         ,mfield
         ,mslot))))

(defun process-field (field &key conc-name alias-for field-offset bool-index bool-values)
  "Process one field descriptor within 'define-message' or 'define-extend'.
Returns a 'proto-field' object, a CLOS slot form, the field index, and lazy reader
name (if lazy).

Arguments
  FIELD: The description of the field as laid out in the proto schema.
  CONC-NAME: The name to concatenate to the beginning of the field accessor.
  ALIAS-FOR is to determine if this is an alias for a difference field.
  FIELD-OFFSET is an internal concept of the index of a field
    in a proto-message.
  BOOL-INDEX: nil if this is not a simple (non-repeated) boolean field.
    If this is a simple boolean field, this is the index into the bit vector of all
    simple boolean fields (i.e., the bool-values argument).
  BOOL-VALUES: A bit-vector holding all boolean values for a message.
    On exit this vector holds the correct default value for FIELD if it is a
    simple boolean field."
  ;; Slot is a symbol giving the field name
  ;; Type is the lisp type specified in a defstruct field or defclass slot.
  ;; Typename is the name of the type from the .proto file.
  ;; Name can be used to override the defaultly generated Protobufs field name.
  ;; Index is the index of the field in the proto.
  ;; Default is the default value for the slot.
  ;; Packed determines if the field is a packed field with respect to proto api.
  ;; Lazy determines whether to lazily deserialize a field with respect to proto api.
  ;; Label is a member of (:repeated :vector), (:repeated :list),
  ;;   (:optional), (:required).
  ;; Documentation is any documentation that has been set for the slot.
  (destructuring-bind (slot &key type typename name (default nil default-p) packed lazy
                            index label documentation &allow-other-keys)
      field
    (let* (;; Public accessors and setters for slots should be defined later.
           (internal-slot-name (intern (format nil "%~A" slot) *protobuf-package*))
           (reader (and conc-name
                        (intern (format nil "~A~A" conc-name slot) *protobuf-package*))))
      (multiple-value-bind (ptype pclass packed-p enum-values root-lisp-type)
          ;; The protobuf returned by clos-type-to-protobuf-type may be incorrect due to
          ;; camel-case shenanigans.  Prefer typename, if available.
          (clos-type-to-protobuf-type type)
        (declare (ignore packed-p enum-values))
        (assert index)
        (multiple-value-bind (label repeated-type) (values-list label)
          (let* ((default
                  (cond ((and (eq label :repeated)
                              (eq repeated-type :vector))
                         $empty-vector)
                        ((eq label :repeated)
                         $empty-list)
                        (default-p default)
                        (t $empty-default)))
                 (cslot (unless alias-for
                          (make-field-data
                           :internal-slot-name internal-slot-name
                           :external-slot-name slot
                           :type `,type
                           :accessor reader
                           :initarg (kintern (symbol-name slot))
                           :initform
                           (cond ((eq label :repeated)
                                     ;; Repeated fields get a container for their elements
                                     (if (eq repeated-type :vector)
                                         `(make-array 5 :fill-pointer 0 :adjustable t)
                                         nil))
                                 ((and (not default-p)
                                          (eq label :optional)
                                          ;; Use unbound for booleans only
                                          (not (eq pclass :bool)))
                                  nil)
                                 (default-p
                                  `,(protobuf-default-to-clos-init default type))))))
                 (field (make-instance
                         'protobuf-field
                         :name  (or name (slot-name->proto slot))
                         :type  (or typename ptype)
                         :lisp-type (when root-lisp-type (qualified-symbol-name root-lisp-type))
                         :set-type type
                         :class pclass
                         :qualified-name (make-qualified-name
                                          *protobuf* (or name (slot-name->proto slot)))
                         :parent *protobuf*
                         :label label
                         :index  index
                         :field-offset field-offset
                         :internal-field-name internal-slot-name
                         :external-field-name slot
                         :reader reader
                         :default default
                         ;; Pack the field only if requested and it actually makes sense
                         :packed  (and (eq label :repeated) packed t)
                         :lazy (and lazy t)
                         :bool-index bool-index
                         :documentation documentation)))
            (when (and bool-index default (not (eq default $empty-default)))
              (setf (bit bool-values bool-index) 1))
            (values field cslot index (and lazy reader))))))))

(defparameter *rpc-package* nil
  "The Lisp package that implements RPC.
   This should be set when an RPC package that uses CL-Protobufs gets loaded.")
(defparameter *rpc-call-function* nil
  "The Lisp function that implements RPC client-side calls.
   This should be set when an RPC package that uses CL-Protobufs gets loaded.")

;; Define a service named 'type' with generic functions declared for
;; each of the methods within the service
(defmacro define-service (type (&key name options
                                documentation source-location)
                          &body method-specs)
  "Define a service named 'type' and Lisp 'defgeneric' for all its methods.
   'name' can be used to override the defaultly generated Protobufs service name.
   'options' is a set of keyword/value pairs, both of which are strings.

   The body is a set of method specs of the form (name (input-type [=>] output-type) &key options).
   'input-type' and 'output-type' may also be of the form (type &key name)."
  (let* ((name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (service (make-instance 'protobuf-service
                    :class type
                    :name  name
                    :qualified-name (make-qualified-name *protobuf* name)
                    :parent *protobuf*
                    :options options
                    :documentation documentation
                    :source-location source-location))
         (index 0))
    (with-collectors ((forms collect-form))
      (dolist (method method-specs)
        (destructuring-bind (function (&rest types)
                             &key name options documentation source-location)
            method
          (let* ((input-type   (first types))
                 (output-type  (if (string= (string (second types)) "=>") (third types) (second types)))
                 (streams-type (if (string= (string (second types)) "=>")
                                 (getf (cdddr types) :streams)
                                 (getf (cddr  types) :streams)))
                 (input-name (and (listp input-type)
                                  (getf (cdr input-type) :name)))
                 (input-streaming (and (listp input-type)
                                       (getf (cdr input-type) :stream)))
                 (input-type (if (listp input-type) (car input-type) input-type))
                 (qual-input-type (make-qualified-name *protobuf* (class-name->proto input-type)))
                 (output-name (and (listp output-type)
                                   (getf (cdr output-type) :name)))
                 (output-streaming (and (listp output-type)
                                        (getf (cdr output-type) :stream)))
                 (output-type (if (listp output-type) (car output-type) output-type))
                 (qual-output-type (make-qualified-name *protobuf* (class-name->proto output-type)))
                 (streams-name (and (listp streams-type)
                                    (getf (cdr streams-type) :name)))
                 (streams-type (if (listp streams-type) (car streams-type) streams-type))
                 (options (loop for (key val) on options by #'cddr
                                collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
                 (package   *protobuf-rpc-package*)
                 (client-fn (intern (format nil "~A-~A" 'call function) package))
                 (server-fn (intern (format nil "~A-~A" function 'impl) package))
                 (method  (make-instance 'protobuf-method
                            :class function
                            :name  (or name (class-name->proto function))
                            :qualified-name (make-qualified-name *protobuf* (or name (class-name->proto function)))
                            :parent service
                            :client-stub client-fn
                            :server-stub server-fn
                            :input-type  input-type
                            :input-name  (or input-name qual-input-type)
                            :input-streaming input-streaming
                            :output-type output-type
                            :output-name (or output-name qual-output-type)
                            :output-streaming output-streaming
                            :streams-type streams-type
                            :streams-name (and streams-type
                                               (or streams-name (class-name->proto streams-type)))
                            :index (iincf index)
                            :options options
                            :documentation documentation
                            :source-location source-location)))
            (appendf (proto-methods service) (list method))
            ;; The following are the hooks to an RPC implementation
            (let* ((vrequest  (intern (symbol-name 'request) package))
                   (vresponse (intern (symbol-name 'response) package))
                   (vchannel  (intern (symbol-name 'channel) package))
                   (vcallback (intern (symbol-name 'callback) package))
                   (vrpc      (intern (symbol-name 'rpc) package)))
              ;; The client side stub, e.g., 'read-air-reservation'.
              ;; The expectation is that the RPC implementation will provide code to make it
              ;; easy to implement a method for this on each kind of channel (HTTP, TCP socket,
              ;; IPC, etc). Unlike C++/Java/Python, we don't need a client-side subclass,
              ;; because we can just use multi-methods.
              ;; The 'do-XXX' method calls the RPC code with the channel, the method
              ;; (i.e., a 'protobuf-method' object), the request and the callback function.
              ;; The RPC code should take care of serializing the input, transmitting the
              ;; request over the wire, waiting for input (or not if it's asynchronous),
              ;; filling in the output, and either returning the response (if synchronous)
              ;; or calling the callback with the response as an argument (if asynchronous).
              ;; It will also deserialize the response so that the client code sees the
              ;; response as an application object.
              (collect-form `(defgeneric ,client-fn (,vchannel ,vrequest &key ,vcallback ,vresponse)
                               ,@(and documentation `((:documentation ,documentation)))
                               #+(or ccl)
                               (declare (values ,output-type))
                               (:method (,vchannel ,vrequest &key ,vcallback ,vresponse)
                                 (declare (ignorable ,vchannel ,vcallback))
                                 (let ((call (and *rpc-package* *rpc-call-function*)))
                                   (assert call ()
                                           "There is no RPC package loaded!")
                                   (funcall call ,vchannel ',method ,vrequest ,vresponse
                                            :callback ,vcallback
                                            ; :type ',input-type
                                            )))))
              ;; The server side stub, e.g., 'do-read-air-reservation'.
              ;; The expectation is that the server-side program will implement
              ;; a method with the business logic for this on each kind of channel
              ;; (HTTP, TCP socket, IPC, etc), possibly on a server-side subclass
              ;; of the input class.
              ;; The business logic is expected to perform the correct operations on
              ;; the input object, which arrived via Protobufs, and produce an output
              ;; of the given type, which will be serialized and sent back over the wire.
              ;; The channel objects hold client identity information, deadline info,
              ;; etc, and can be side-effected to indicate success or failure.
              ;; The RPC code provides the channel classes and does (de)serialization, etc.
              ;; The VRPC argument is always of type RPC2:SERVER-RPC.
              (collect-form `(defgeneric ,server-fn (,vchannel ,vrequest ,vrpc)
                               ,@(and documentation `((:documentation ,documentation)))
                               #+(or ccl)
                               (declare (values ,output-type))))))))
      (collect-form `(appendf (proto-services *protobuf*) (list ,service)))
      (if source-location
          `(progn
             (with-proto-source-location (,type ,name protobuf-service ,@source-location)
               ,@forms))
          `(progn ,@forms)))))


;; Lisp-only type aliases
(defmacro define-type-alias (type (&key name alias-for documentation source-location)
                             &key lisp-type proto-type serializer deserializer)
  "Define a Protobufs type alias Lisp 'deftype' named 'type'.
   'lisp-type' is the name of the Lisp type.
   'proto-type' is the name of a primitive Protobufs type, e.g., 'int32' or 'string'.
   'serializer' is a function that takes a Lisp object and generates a Protobufs object.
   'deserializer' is a function that takes a Protobufs object and generates a Lisp object.
   If 'alias-for' is given, no Lisp 'deftype' will be defined."
  (multiple-value-bind (type-str proto)
      (lisp-type-to-protobuf-type proto-type)
    (assert (keywordp proto) ()
            "The alias ~S must resolve to a Protobufs primitive type"
            type)
    (let* ((name  (or name (class-name->proto type)))
           (alias (make-instance 'protobuf-type-alias
                    :class  type
                    :name   name
                    :lisp-type  lisp-type
                    :proto-type proto
                    :proto-type-str type-str
                    :serializer   serializer
                    :deserializer deserializer
                    :qualified-name (make-qualified-name *protobuf* name)
                    :parent *protobuf*
                    :documentation documentation
                    :source-location source-location)))
      (with-collectors ((forms collect-form))
        (if alias-for
            ;; If we've got an alias, define a a type that is the subtype of
            ;; the Lisp enum so that typep and subtypep work
            (unless (eq type alias-for)
              (collect-form `(deftype ,type () ',alias-for)))
            ;; If no alias, define the Lisp enum type now
            (collect-form `(deftype ,type () ',lisp-type)))
        (record-protobuf-object type alias :alias)
        (collect-form `(record-protobuf-object ',type ,alias :alias))
        (if source-location
            `(progn
               (with-proto-source-location (,type ,name protobuf-type-alias ,@source-location)
                 ,@forms))
            `(progn ,@forms))))))
