;;; Copyright 2012-2020 Google LLC
;;;
;;; Use of this source code is governed by an MIT-style
;;; license that can be found in the LICENSE file or at
;;; https://opensource.org/licenses/MIT.

(in-package "PROTO-IMPL")


;;; Protocol buffer defining macros


#|
Notes on macroexpansion:

The lisp generated proto file should look like:

-------------------------------

;; In a package named "cl-protobufs.<the-proto-package-name>"

(proto:define-message color-wheel1
    (:conc-name "")
  ;; Nested messages.
  (proto:define-message color-wheel1.metadata1
      (:conc-name "")
    ;; Fields.
    (author  :index 1  :type cl:string :label (:optional) :typename "string")
    (revision  :index 2  :type cl:string :label (:optional) :typename "string")
    (date  :index 3  :type cl:string :label (:optional) :typename "string"))
  ;; Fields.
  (name  :index 1  :type cl:string :label (:required) :typename "string")
  (colors  :index 2  :type (proto:list-of color1) :label (:repeated :list)
           :typename "Color1")
  (metadata  :index 3  :type (cl:or cl:null color-wheel1.metadata1)
             :label (:optional) :typename "Metadata1"))

(cl:setf (cl:gethash #P"third_party/lisp/cl_protobufs/tests/serialization.proto"
                     proto-impl::*all-schemas*)
         (proto:find-schema 'serialization-test))

(export ...)
-------------------------------

The define-schema form stores the file-descriptor for the current file in
*current-file-descriptor*. The file-descriptor holds the protobuf-service
objects that are generated by the define-service macro.

TODO(jgodbout): Remove all schema.

Next we get into the define-* macro's.

The possible top level define macros are:
- define-enum
- define-message
- define-extend
- define-service

Inside of those macros there may also be define-* macros:
- define-enum
- define-message
- define-group
- define-extension
- define-extend
- define-service
- define-map
- define-oneof

The most common define-* macros we will see are the macros that
define messages, which generate PROTOBUF-MESSAGE classes and
create the message structures that hold data. These are:
- define-message
- define-group
- define-extend

DEFINE-ENUM:

The define-enum macro creates a ENUM-DESCRIPTOR meta-object as well
as a type with enum-name being (MEMBER :enum-1 :enum-2 ...).
It also creates methods to access the default-enum, and convert
from the enum keyword to the enum index and back.

If the enum being defined is at top level in the proto then
then we output the result of the macro directly.
If the enum is nested in other define forms, then we
save the output of define-enum in a global and output the
enum definitions before any other definitions. This guarantees
the enum type is available for other messages definitions.

DEFINE-EXTENSION:

The define-extension macro defines a PROTOBUF-EXTENSION meta-object and
set it in a PROTOBUF-MESSAGE meta-object.

This meta-object details the possible range indices of proto extensions
allowed in a protobuf message.

DEFINE-EXTEND:

The define-extend macro creates a PROTOBUF-MESSAGE meta-object that
overrides a PROTOBUF-MESSAGE meta-object created in define-message or
define-group. The new meta-object will be identical to the original
but with extra fields.

We return forms to create this meta-object as well as accessors and
setters for the new fields.

DEFINE-MESSAGE DEFINE-GROUP:

The define-message and define-group macros work much the same way.
They take the type (message name) and a list of sub-elements which
may include define-message, define-group, define-extension, define-extend,
define-enum, or a field which is just a declaration of the field object in a proto.

Example:   (author  :index 1  :type cl:string :label (:optional) :typename "string")

First we create the PROTOBUF-MESSAGE meta-object that is defined in the
define-message lambda list and store it in *current-message-descriptor*.  If we
see a define-message or define-group we recursively call the define macro to
create a subgroup which will be named:

  top-level-message.submessage1.submessage2

We save the resultant forms that are output as so define-message or define-group
may output them at the and of the macro-call.

If we see a define-enum, define-message, or define-extend macro
we save the resultant form to a list of forms to output.

If we see a define-group form we call it and it creates a message just like
define-message. The only difference is a group acts as a field in a message
as well as being an message type in the message, so we must add a field to the
PROTOBUF-MESSAGE meta-object as if it were a field.

If we see a field we call process-field which creates a FIELD-DESCRIPTOR
containing details of the field and returns a form to create this meta-object.
We save the form for both output and future processing.

Next we call MAKE-STRUCTURE-CLASS-FORMS that takes the field meta-objects
and creates forms for creating defstruct form for the proto data container
that will be used in client code. This is where the accessors, setters, and has
functions are defined. It outputs all of the forms to create these objects.

Finally we output all of the created forms.

DEFINE-SERVICE:

The define-service macro creates forms that make the SERVICE-DESCRIPTOR, add it to the
PROTOBUF-SCHEMA meta-object, and create method stubs for the service implementation.

Note: Actually using services require a gRPC plugin.

DEFINE-ONEOF:

The define-oneof macro takes a body of field defintions and creates a ONEOF-DESCRIPTOR
meta-object which holds field descriptors for the fields in its body. This
ONEOF-DESCRIPTOR gets appended to the message's PROTO-ONEOFS slot. Then,
MAKE-STRUCTURE-CLASS-FORMS will use the PROTO-ONEOFS slot to create forms for accessing
the oneof and its nested fields.
|#


;;; TODO(jgodbout): remove this, we already have field-descriptor
;;; "The only reason you would ever want a field-data struct instead of a
;;; field-descriptor is when you define a slot on the object which doesn't
;;; constitute a field (i.e. the %%BOOL-VALUES and %%IS-SET vectors). So in
;;; that sense, the name field-data is quite bad." --bkuehnert
(defstruct field-data
  "Keep field metadata for making the structure object."
  (internal-slot-name nil :type symbol)
  (external-slot-name nil :type symbol)
  (container nil :type (member nil :vector :list))
  (accessor nil)
  (type nil)
  (kind nil)
  (initarg nil)
  (initform nil))

(defun validate-imports (file-descriptor imports)
  "Validates that all of the IMPORTS (a list of file names) have
   already been loaded. FILE-DESCRIPTOR is the descriptor of the
   file doing the importing."
  (dolist (import (reverse imports))
    (let* ((imported (proto:find-schema (if (stringp import) (pathname import) import))))
      (unless imported
        (error "Could not find file ~S imported by ~S" import file-descriptor)))))

(defun define-schema (type &key name syntax package import
                           optimize options)
  "Define a schema named TYPE, corresponding to a .proto file of that name.
   NAME can be used to override the defaultly generated Protobufs name.
   SYNTAX and PACKAGE are as they would be in a .proto file.
   IMPORT is a list of pathname strings to be imported.
   OPTIMIZE can be either :space (the default) or :speed; if it is :speed, the
   serialization code will be much faster, but much less compact.
   OPTIONS is a property list, i.e., (\"key1\" \"val1\" \"key2\" \"val2\" ...)."
  (let* ((name     (or name (class-name->proto type)))
         (package  (and package (if (stringp package)
                                    package
                                    (string-downcase (string package)))))
         (options  (remove-options
                    (loop for (key val) on options by #'cddr
                          collect (make-option
                                   (if (symbolp key)
                                       (slot-name->proto key)
                                       key)
                                   val))
                    "optimize_for"))
         (imports  (if (listp import) import (list import)))
         (schema   (make-instance
                    'file-descriptor
                    :class    type
                    :name     name
                    ;; CCL requires syntax to be OR'd  with :proto2 or :proto3
                    ;; in case syntax is NIL.
                    :syntax   (or syntax :proto2 :proto3)
                    :package  package
                    :imports  imports
                    :options  (if optimize
                                  (append options
                                          (list (make-option
                                                 "optimize_for"
                                                 (if (eq optimize :speed)
                                                     "SPEED"
                                                     "CODE_SIZE")
                                                 'symbol)))
                                  options))))
    (record-schema schema)
    (setf *current-file-descriptor* schema)
    (validate-imports schema imports)))

(defun %make-enum->numeral-table (enum-values)
  "Makes a hash table mapping enum values to numerals.
ENUM-VALUES is a list of ENUM-VALUE-DESCRIPTORs."
  `(case enum
     ,@(loop for v in enum-values
             collect
             `(,(enum-value-descriptor-name v) ,(enum-value-descriptor-value v)))))

(defun %make-numeral->enum-table (enum-values)
  "Makes a hash table mapping enum values to numerals.
ENUM-VALUES is a list of ENUM-VALUE-DESCRIPTORs."
  `(case numeral
     ,@(loop with mapped = (make-hash-table)
             for v in enum-values
             for enum-value = (enum-value-descriptor-value v)
             for already-set-p = (gethash enum-value mapped)
             unless already-set-p
               do (setf (gethash enum-value mapped) t)
             unless already-set-p
               collect `(,enum-value ,(enum-value-descriptor-name v)))))

(deftype numeral () "byte 32" '(signed-byte 32))

(defgeneric cl-protobufs:numeral->enum (enum numeral &optional default)
  (:documentation
   "Converts a NUMERAL to a corresponding ENUM keyword.
ENUM is a Lisp symbol name of the ENUM.
DEFAULT the default value if NUMERAL in not contained in the ENUM."))

(deftype quoted-symbol () "(quote sym)" '(cons (eql quote) (cons symbol)))

(defgeneric cl-protobufs:enum->numeral (enum keyword &optional default)
  (:documentation
   "Converts an ENUM keyword to a corresponding ENUM KEYWORD.
ENUM is a Lisp symbol name of the ENUM.
DEFAULT the default value if KEYWORD is a not contained in ENUM."))

(defun make-enum<->numeral-forms (type enum-values)
  "Generates forms for enum<->numeral conversion functions.
TYPE is the enum type name.  ENUM-VALUES is a list of ENUM-VALUE-DESCRIPTORs."
  (let ((enum->numeral (fintern "~A->NUMERAL" type))
        (numeral->enum (fintern "NUMERAL->~A" type)))
    `(progn
       (defun ,enum->numeral (enum &optional default)
         (declare (symbol enum))
         (let ((numeral ,(%make-enum->numeral-table enum-values)))
           (if numeral numeral default)))

       (defun ,numeral->enum (numeral &optional default)
         (declare (numeral numeral))
         (let ((enum ,(%make-numeral->enum-table enum-values)))
           (if enum enum default)))

       (setf (get ',type 'numeral->enum) ',numeral->enum)
       (setf (get ',type 'enum->numeral) ',enum->numeral)

       (defmethod cl-protobufs:enum->numeral
           ((e (eql ',type)) keyword &optional default)
         (,enum->numeral keyword default))
       (defmethod cl-protobufs:numeral->enum
           ((e (eql ',type)) numeral &optional default)
         (,numeral->enum numeral default)))))

(defgeneric enum-default-value (enum-type)
  (:documentation
   "Get the default enum value for ENUM-TYPE"))

(defmethod enum-default-value (enum-type)
  "If no default enum value function can be found for a specific ENUM-TYPE
return nil."
  nil)

(defun make-enum-default (type enum-values)
  "Generate a function to return the default enum value for
an enum of type TYPE. The default value should be the first
enum in ENUM-VALUES."
  `(defmethod enum-default-value ((e (eql ',type)))
     ,(enum-value-descriptor-name (car enum-values))))

(defun make-enum-constant-forms (type enum-values)
  "Generates forms for defining a constant for each enum value in ENUM-VALUES.
TYPE is the enum type name.  ENUM-VALUES is a list of ENUM-VALUE-DESCRIPTORs.

Constant names are in the form of +<message_name>.<value_name>+ when the enum is defined in a
message, and of +<value_name>+ when the enum is defined at top-level."
  (let* ((enum-name (symbol-name type))
         (dot (position #\. enum-name :test #'char= :from-end t))
         ;; Use C/C++ enum scope.
         (scope (and dot (subseq enum-name 0 dot)))
         (constants
          (loop for v in enum-values
                for c = (fintern "+~@[~A.~]~A+" scope (enum-value-descriptor-name v))
                collect `(defconstant ,c ,(enum-value-descriptor-value v)))))
    `(progn
       ,@constants
       (export ',(mapcar #'second constants)))))

(defun enum-values (enum-type)
  "Returns all keyword values that belong to the given ENUM-TYPE."
  (let ((expansion (type-expand enum-type)))
    (check-type expansion (cons (eql member) list))
    (rest expansion)))

(defvar *enum-forms* nil
  "The enum forms have to be evaluated first as they become types
for messages and sadly the messages can be defined before the enums.")

(defun create-progn-with-enum-forms-if-top-level (top-level-form-p &rest lists)
  "Create the output progn form for a define statement which may be top-level
and have an enum inside of it. If it is top level output the internal enums
before the rest of the forms, otherwise just output the forms collected.
Parameters:
  TOP-LEVEL-FORM-P: Bool stating whether this is top-level or not.
  LISTS: The lists that have been collected in the defining form for output."
  (let (out-list)
    ;; Our foolish version of one-level flatten
    (dolist (list (reverse lists))
      (dolist (inner-list (reverse list))
        (push inner-list out-list)))

    (if (and top-level-form-p *enum-forms*)
        (let ((output
               `(progn ,@*enum-forms* ,@out-list)))
          (setf *enum-forms* nil)
          output)
        `(progn ,@out-list))))

(defmacro define-enum (type (&key name conc-name alias-for)
                       &body values)
  "Define a Lisp type given the data for a protobuf enum type.
Also generates conversion functions between enum values and numerals.  Function names are
<enum_name>->NUMERAL and NUMERAL-><enum_name>, respectively.
Both accept an optional default argument.

Parameters:
  TYPE: The name of the type.
  NAME: Override for the protobuf enum type name.
  CONC-NAME: Prefix to the defaultly generated protobuf enum name.
  ALIAS-FOR: Make this enum an alias for another type.
  VALUES: The possible values for the enum in the form (name :index value)."
  (let ((name (or name (class-name->proto type)))
        (prefix (conc-name-for-type type conc-name)))
    (with-collectors ((names collect-name) ; keyword symbols
                      (forms collect-form)
                      (value-descriptors collect-value-descriptor))
      ;; The middle value is :index, useful for readability of generated code...
      ;; (Except that the value is not actually an index, nor is the slot called index anymore.)
      (loop for (name nil value) in values do
        (let* ((val-name (kintern (if prefix
                                      (format nil "~A~A" prefix name)
                                      (symbol-name name))))
               (val-desc (make-enum-value-descriptor :value value :name val-name)))
          (collect-name val-name)
          (collect-value-descriptor val-desc)))
      (let ((enum (make-enum-descriptor
                   :class  type
                   :name   name
                   :alias-for (if (listp alias-for)
                                  alias-for
                                  (list alias-for))
                   :values value-descriptors)))
        (cond ((and alias-for (not (eq type alias-for)))
               ;; If we've got an alias, define a type that is a subtype of
               ;; the Lisp enum so that typep and subtypep work.
               (collect-form `(deftype ,type () ',alias-for)))
              ((null alias-for)
               (collect-form `(deftype ,type () '(member ,@names)))
               (collect-form (make-enum<->numeral-forms type value-descriptors))
               (collect-form (make-enum-constant-forms type value-descriptors))
               (collect-form (make-enum-default type value-descriptors))))
        (collect-form `(record-protobuf-object ',type ,enum :enum))
        ;; Register it by the full symbol name.
        (record-protobuf-object type enum :enum))
      ;; This is messy and should be fixed.
      ;; Enums define types and functions that will need to be called
      ;; when creating messages. As such they need to be first
      ;; in the list of things a macro evaluated. So we make a global var
      ;; and gaurantee they are first.
      (when *current-message-descriptor* ; enum is nested inside a message
        (push `(progn ,@forms) *enum-forms*))
      `(progn ,@forms))))

(defmacro define-map (type-name &key key-type val-type json-name index val-kind)
"Define a lisp type given the data for a protobuf map type.

Parameters:
  TYPE-NAME: Map type name.
  KEY-TYPE: The lisp type of the map's keys.
  VAL-TYPE: The lisp type of the map's values.
  JSON-NAME: The string to use as a JSON name for the field.
  VAL-KIND: The protobuf kind of the map value type.
  INDEX: Index of this map type in the field."
  (assert json-name)
  (assert val-kind)
  (check-type index integer)
  (let* ((slot      type-name)
         (name      (class-name->proto type-name))
         (reader    (let ((msg-conc (proto-conc-name *current-message-descriptor*)))
                      (and msg-conc
                           (fintern "~A~A" msg-conc slot))))
         (internal-slot-name (fintern "%~A" slot))
         (qual-name (make-qualified-name *current-message-descriptor* (slot-name->proto slot)))
         (class (fintern (uncamel-case qual-name)))
         (mslot  (make-field-data
                  :internal-slot-name internal-slot-name
                  :external-slot-name slot
                  :type 'hash-table
                  :initform (if (eql key-type 'cl:string)
                                '(make-hash-table :test #'equal)
                                '(make-hash-table :test #'eq))
                  :accessor reader))
         (mfield (make-instance 'field-descriptor
                  :name (slot-name->proto slot)
                  :class class
                  :qualified-name qual-name
                  :label :optional
                  :index index
                  :internal-field-name internal-slot-name
                  :external-field-name slot
                  :json-name json-name
                  :reader reader
                  :type 'cl:hash-table
                  :kind :map))
         (map-desc (make-map-descriptor
                    :class class
                    :name name
                    :key-class (lisp-type-to-protobuf-class key-type)
                    ;; If the value type is a message, then VAL-TYPE will take the form
                    ;; (cl:or cl:null message). In this case, set VAL-CLASS to be 'message'
                    ;; as that is the class of the value type.
                    :val-class (if (listp val-type)
                                   (destructuring-bind (a b msg-type) val-type
                                     (assert (and (eq a 'or) (eq b 'null)))
                                     msg-type)
                                   (lisp-type-to-protobuf-class val-type))
                    :key-type key-type
                    :val-type val-type
                    :val-kind val-kind)))
    (record-protobuf-object class map-desc :map)
    `(progn
       define-map ;; the type of this model
       map-desc   ;; the model data.
       ((record-protobuf-object ',class ,map-desc :map)) ;; forms necessary for defining the map
       ,mfield    ;; the extra field-data object created by this macro
       ,mslot)))  ;; the extra field-descriptor object created by this macro.

(defmacro define-oneof (name (&key synthetic-p) &body fields)
  "Creates a oneof descriptor and the defining forms for its fields.

Parameters:
  NAME: The name of the oneof.
  SYNTHETIC-P: If true, this oneof is automatically generated by protoc, in
    which case the special oneof accessors should not be created.
  FIELDS: Field as output by protoc."
  (let* ((internal-name (fintern "%~A" name))
         (field-descriptors (make-array (length fields))))
    (loop for field in fields
          for oneof-offset from 0
          do
       (destructuring-bind (slot &key type name (default nil default-p)
                                 lazy json-name index kind &allow-other-keys)
           field
         (assert json-name)
         (assert index)
         (let ((default (if default-p default $empty-default)))

           (multiple-value-bind (ptype pclass)
               (clos-type-to-protobuf-type type)
             (declare (ignore ptype))
             (setf (aref field-descriptors oneof-offset)
                   (make-instance 'field-descriptor
                                  :name (or name (slot-name->proto slot))
                                  :type type
                                  :kind kind
                                  :class pclass
                                  :qualified-name (make-qualified-name
                                                   *current-message-descriptor*
                                                   (or name (slot-name->proto slot)))
                                  :label :optional
                                  :index index
                                  ;; Oneof fields don't have a bit in the %%is-set vector, as field
                                  ;; presence is tracked via the SET-FIELD slot of the oneof struct.
                                  :field-offset nil
                                  :internal-field-name internal-name
                                  :external-field-name slot
                                  :json-name json-name
                                  :oneof-offset oneof-offset
                                  :default default
                                  :lazy (and lazy t)))))))
    `(progn
       ,(make-oneof-descriptor :internal-name internal-name
                               :external-name name
                               :synthetic-p (and synthetic-p t)
                               :fields field-descriptors))))

(defun-inline proto-%bytes (obj)
  "Returns the %bytes field of the proto object OBJ."
  (slot-value obj '%bytes))

(defun-inline (setf proto-%bytes) (new-value obj)
  "Sets the %bytes field of the proto object OBJ with NEW-VALUE."
  (setf (slot-value obj '%bytes) new-value))

(defstruct field-accessors
  "Structure containing the get, set, and has functions
for a proto-message field."
  (get nil :type symbol)
  (set nil :type list)
  (has nil :type symbol)
  (clear nil :type symbol))

(defun set-field-accessor-functions (message-name field-name)
  "Set the get, set, and has functions for a proto field on a fields symbol p-list.
Parameters:
  MESSAGE-NAME: The symbol name of the protobuf message containing the field.
  FIELD-NAME: The symbol name for the field."
  (setf (get field-name message-name)
        (make-field-accessors
         :get (proto-slot-function-name message-name field-name :get)
         :set `(setf ,(proto-slot-function-name message-name field-name :get))
         :has (proto-slot-function-name message-name field-name :has)
         :clear (proto-slot-function-name message-name field-name :clear))))

(defun make-common-forms-for-structure-class (proto-type public-slot-name slot-name field)
  "Create the common forms needed for all message fields has, is-set, clear, set.

 Parameters:
  PROTO-TYPE: The Lisp type name of the proto message.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix).
  SLOT-NAME: Slot name for the field (with the #\% prefix).
  FIELD: The class object field definition of the field."
  (let ((public-accessor-name (proto-slot-function-name proto-type public-slot-name :get))
        (is-set-accessor (fintern "~A-%%IS-SET" proto-type))
        (hidden-accessor-name (fintern "~A-~A" proto-type slot-name))
        (has-function-name (proto-slot-function-name proto-type public-slot-name :has))
        (default-form (get-default-form (proto-type field)
                                        (proto-default field)
                                        (proto-container field)
                                        (proto-type field)))
        (index (proto-field-offset field))
        (clear-function-name (proto-slot-function-name proto-type public-slot-name :clear))
        (bool-index (proto-bool-index field))
        (bit-field-name (fintern "~A-%%BOOL-VALUES" proto-type)))
    ;; If index is nil, then this field does not have a reserved bit in the %%is-set vector.
    ;; This means that the field is proto3-style optional, so checking for field presence must
    ;; be done by checking if the bound value is default.
    (with-gensyms (obj new-value cur-value)
      `(
        (defun-inline (setf ,public-accessor-name) (,new-value ,obj)
          ,(when index
             `(setf (bit (,is-set-accessor ,obj) ,index) 1))
          ,(if bool-index
               `(setf (bit (,bit-field-name ,obj) ,bool-index)
                      (if ,new-value 1 0))
               `(setf (,hidden-accessor-name ,obj) ,new-value)))


        ;; For proto3-style optional fields, the has-* function is repurposed. It now answers the
        ;; question: "Is this field set to the default value?". This is done so that the optimized
        ;; serializer can use the has-* function to check if an optional field should be serialized.
        (defun-inline ,has-function-name (,obj)
          ,(if index
               `(= (bit (,is-set-accessor ,obj) ,index) 1)
               `(let ((,cur-value ,(if bool-index
                                       `(plusp (bit (,bit-field-name ,obj) ,bool-index))
                                       `(,hidden-accessor-name ,obj))))
                  ,(if (proto-container field)
                       cur-value
                       (case (proto-type field)
                         ((proto:byte-vector cl:string) `(not (= (length ,cur-value) 0)))
                         ((cl:double-float cl:float) `(not (= ,cur-value ,default-form)))
                         ;; Otherwise, the type is integral. EQ suffices to check equality.
                         (t `(not (eq ,cur-value ,default-form))))))))

        ;; Clear function
        ;; Map type clear functions are created in make-map-accessor-forms.
        ;; todo(benkuehnert): rewrite map types/definers so that this isn't necessary
        ,@(unless (eq (proto-kind field) :map)
            `((defun-inline ,clear-function-name (,obj)
                ,(when index
                   `(setf (bit (,is-set-accessor ,obj) ,index) 0))
                ,(if bool-index
                     `(setf (bit (,bit-field-name ,obj) ,bool-index)
                            ,(if default-form 1 0))
                     `(setf (,hidden-accessor-name ,obj) ,default-form)))))

        ;; Create defmethods to allow for getting/setting compatibly
        ;; with the standard-classes.
        (defmethod ,public-slot-name ((,obj ,proto-type))
          (,public-accessor-name ,obj))

        (defmethod (setf ,public-slot-name) (,new-value (,obj ,proto-type))
          (setf (,public-accessor-name ,obj) ,new-value))

        (proto-impl::set-field-accessor-functions ',proto-type ',public-slot-name)

        ;; has-* functions are not exported for proto3-style optional fields. They are only for
        ;; internal usage.
        ,(unless (eq (proto-syntax *current-file-descriptor*) :proto3)
           `(export '(,has-function-name)))

        ,(unless (eq (proto-kind field) :map)
           `(export '(,clear-function-name)))

        (export '(,public-accessor-name))))))

(defun make-oneof-accessor-forms (proto-type oneof)
  "Make and return forms that define accessor functions for a oneof and its fields.

Paramters:
  PROTO-TYPE: The lisp name of the containing message of this oneof.
  ONEOF: The oneof-descriptor of the oneof to make accessors for."
  (let* ((public-slot-name (oneof-descriptor-external-name oneof))
         (hidden-slot-name (oneof-descriptor-internal-name oneof))
         (hidden-accessor-name (fintern "~A-~A" proto-type hidden-slot-name))
         (case-function-name (proto-slot-function-name proto-type public-slot-name :case))
         (has-function-name (proto-slot-function-name proto-type public-slot-name :has))
         (clear-function-name (proto-slot-function-name proto-type public-slot-name :clear)))
    (with-gensyms (obj)
      `(
        ;; Since the oneof struct stores an integer to indicate which field is set, it is not
        ;; particularly useful for the user when writing code surrounding oneof types. This
        ;; creates a function which returns a symbol with the same name as the field which
        ;; is currently set. If the field is not set, this function returns nil.
        (defun-inline ,case-function-name (,obj)
          (ecase (oneof-set-field (,hidden-accessor-name ,obj))
            ,@(loop for field across (oneof-descriptor-fields oneof)
                    collect
                    `(,(proto-oneof-offset field) ',(proto-external-field-name field)))
            ((nil) nil)))

        (defun-inline ,has-function-name (,obj)
          (not (eql (oneof-set-field (,hidden-accessor-name ,obj)) nil)))

        (defun-inline ,clear-function-name (,obj)
          (setf (oneof-value (,hidden-accessor-name ,obj)) nil)
          (setf (oneof-set-field (,hidden-accessor-name ,obj)) nil))

        ;; Special oneof forms are only created when ONEOF is not synthetic.
        ,(unless (oneof-descriptor-synthetic-p oneof)
           `(export '(,case-function-name ,has-function-name ,clear-function-name)))

        ;; Fields inside of a oneof need special accessors, since they need to consult
        ;; with the oneof struct. This creates those special accessors for each field.
        ;; This mostly mirrors what happens in make-common-forms-for-structure-class
        ;; and make-structure-class-forms-non-lazy, but they consult the oneof struct
        ;; to check if they are set.
        ,@(loop
            for field across (oneof-descriptor-fields oneof)
            append
            (let* ((public-slot-name (proto-external-field-name field))
                   (public-accessor-name (proto-slot-function-name
                                          proto-type public-slot-name :get))
                   (has-function-name    (proto-slot-function-name
                                          proto-type public-slot-name :has))
                   (clear-function-name  (proto-slot-function-name
                                          proto-type public-slot-name :clear))
                   (default-form (get-default-form (proto-type field)
                                                   (proto-default field)
                                                   (proto-container field)
                                                   (proto-kind field)))
                   (field-type (proto-type field))
                   (oneof-offset (proto-oneof-offset field)))
              ;; If a field isn't currently set inside of the oneof, just return its
              ;; default value.
              (with-gensyms (obj new-value bytes field-obj)
                `((defun-inline ,public-accessor-name (,obj)
                    (if (eq (oneof-set-field (,hidden-accessor-name ,obj))
                            ,oneof-offset)
                        ,(if (proto-lazy-p field)
                             `(let* ((,field-obj (oneof-value (,hidden-accessor-name ,obj)))
                                     (,bytes (and ,field-obj (proto-%bytes ,field-obj))))
                                (if ,bytes
                                    (setf (oneof-value (,hidden-accessor-name ,obj))
                                          (%deserialize-object ',(proto-class field)
                                                               ,bytes nil nil))))
                             `(oneof-value (,hidden-accessor-name ,obj)))
                        ,default-form))

                  (defun-inline (setf ,public-accessor-name) (,new-value ,obj)
                    (declare (type ,field-type ,new-value))
                    (setf (oneof-set-field (,hidden-accessor-name ,obj))
                          ,oneof-offset)
                    (setf (oneof-value (,hidden-accessor-name ,obj)) ,new-value))

                  (defun-inline ,has-function-name (,obj)
                    (eq (oneof-set-field (,hidden-accessor-name ,obj))
                        ,oneof-offset))

                  (defun-inline ,clear-function-name (,obj)
                    (when (,has-function-name ,obj)
                      (setf (oneof-value (,hidden-accessor-name ,obj)) nil)
                      (setf (oneof-set-field (,hidden-accessor-name ,obj)) nil)))

                  (defmethod ,public-slot-name ((,obj ,proto-type))
                    (,public-accessor-name ,obj))

                  (defmethod (setf ,public-slot-name) (,new-value (,obj ,proto-type))
                    (setf (,public-accessor-name ,obj) ,new-value))

                  (proto-impl::set-field-accessor-functions ',proto-type ',public-slot-name)

                  (export '(,has-function-name ,clear-function-name
                            ,public-accessor-name))))))))))

(defun make-map-accessor-forms (proto-type public-slot-name slot-name field)
  "This creates forms that define map accessors which are type safe. Using these will
guarantee that the resulting map can be properly serialized, whereas if one modifies
the underlying map (which is accessed via the make-common-forms-for-structure-class
function) then there is no guarantee on the serialize function working properly.

 Parameters:
  PROTO-TYPE: The Lisp type name of the proto message.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix).
  SLOT-NAME: Slot name for the field (with the #\% prefix).
  FIELD: The class object field definition of the field."
  (let* ((public-accessor-name (proto-slot-function-name proto-type public-slot-name :map-get))
         (public-remove-name (proto-slot-function-name proto-type public-slot-name :map-rem))
         (clear-function-name (proto-slot-function-name proto-type public-slot-name :clear))
         (method-accessor-name (fintern "~A-gethash" public-slot-name))
         (method-remove-name (fintern "~A-remhash" public-slot-name))
         (hidden-accessor-name (fintern "~A-~A"  proto-type slot-name))
         (map-descriptor (find-map-descriptor (proto-class field)))
         (key-type (map-descriptor-key-type map-descriptor))
         (val-type (map-descriptor-val-type map-descriptor))
         (val-kind (map-descriptor-val-kind map-descriptor))
         (val-default-form (get-default-form val-type $empty-default nil val-kind))
         (is-set-accessor (fintern "~A-%%IS-SET" proto-type))
         (index (proto-field-offset field)))

    (with-gensyms (obj new-val new-key)
      `(
        (defun-inline (setf ,public-accessor-name) (,new-val ,new-key ,obj)
          (declare (type ,key-type ,new-key)
                   (type ,val-type ,new-val))
          (setf (bit (,is-set-accessor ,obj) ,index) 1)
          (setf (gethash ,new-key (,hidden-accessor-name ,obj)) ,new-val))

        ;; If the map's value type is a message, then the default value returned
        ;; should be nil. However, we do not want to allow the user to insert nil
        ;; into the map, so this binding only applies to get function.
        ,@(let ((val-type (if (member val-kind '(:message :group :extends))
                              (list 'or 'null val-type)
                              val-type)))

            `((defun-inline ,public-accessor-name (,new-key ,obj)
                (declare (type ,key-type ,new-key))
                (the (values ,val-type t)
                     (multiple-value-bind (val flag)
                         (gethash ,new-key (,hidden-accessor-name ,obj))
                       (if flag
                           (values val flag)
                           (values ,val-default-form nil)))))))

        (defun-inline ,public-remove-name (,new-key ,obj)
          (declare (type ,key-type ,new-key))
          (remhash ,new-key (,hidden-accessor-name ,obj))
          (if (= 0 (hash-table-count (,hidden-accessor-name ,obj)))
              (setf (bit (,is-set-accessor ,obj) ,index) 0)))

        (defun-inline ,clear-function-name (,obj)
          ,(when index
             `(setf (bit (,is-set-accessor ,obj) ,index) 0))
          (setf (,hidden-accessor-name ,obj) ,(if (eql key-type 'cl:string)
                                                  '(make-hash-table :test #'equal)
                                                  '(make-hash-table :test #'eq))))

        ;; These defmethods have the same functionality as the functions defined above
        ;; but they don't require a refernece to the message type, so using them is more
        ;; convenient.
        (defmethod (setf ,method-accessor-name) (,new-val ,new-key (,obj ,proto-type))
          (setf (,public-accessor-name ,new-key ,obj) ,new-val))

        (defmethod ,method-accessor-name (,new-key (,obj ,proto-type))
          (,public-accessor-name ,new-key ,obj))

        (defmethod ,method-remove-name (,new-key (,obj ,proto-type))
          (,public-remove-name ,new-key ,obj))

        (export '(,public-accessor-name
                  ,public-remove-name
                  ,clear-function-name
                  ,method-accessor-name
                  ,method-remove-name))))))

(defun make-structure-class-forms-lazy (proto-type field public-slot-name)
  "Makes forms for the lazy fields of a proto message using STRUCTURE-CLASS.

 Parameters:
  PROTO-TYPE: The Lisp type name of the proto message.
  FIELD: The field definition for which to define accessors.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix)."
  (let* ((slot-name (proto-internal-field-name field))
         (repeated (eq (proto-label field) :repeated))
         (vectorp (eq :vector (proto-container field)))
         (public-accessor-name (proto-slot-function-name proto-type public-slot-name :get))
         (hidden-accessor-name (fintern "~A-~A" proto-type slot-name)))
    (with-gensyms (obj field-obj bytes)
      `((defun-inline ,public-accessor-name (,obj)
          ,(if (not repeated)
               `(let* ((,field-obj (,hidden-accessor-name ,obj))
                       (,bytes (and ,field-obj (proto-%bytes ,field-obj))))
                  (if ,bytes
                      (setf (,hidden-accessor-name ,obj)
                            ;; Re-create the field object by deserializing its %bytes
                            ;; field.
                            (%deserialize-object ',(proto-class field) ,bytes nil nil))
                      ,field-obj))
               `(let ((,field-obj (,hidden-accessor-name ,obj)))
                  (if (notany #'proto-%bytes ,field-obj)
                      ,field-obj
                      ,(with-gensyms (maybe-deserialize-object field-element)
                         `(flet ((,maybe-deserialize-object (,field-element)
                                   (let ((,bytes (proto-%bytes ,field-element)))
                                     (if ,bytes
                                         ;; Re-create the field object by deserializing
                                         ;; its %bytes field.
                                         (%deserialize-object ',(proto-class field) ,bytes nil nil)
                                         ,field-element))))
                            (setf (,hidden-accessor-name ,obj)
                                  ,(if vectorp
                                       `(map 'vector #',maybe-deserialize-object
                                             (the vector ,field-obj))
                                       `(mapcar #',maybe-deserialize-object ,field-obj)))))))))
        ,@(make-common-forms-for-structure-class proto-type public-slot-name slot-name field)))))

(defun make-structure-class-forms-non-lazy (proto-type field public-slot-name)
  "Makes forms for the non-lazy fields of a proto message.

 Parameters:
  PROTO-TYPE: The Lisp type name of the proto message.
  FIELD: The field definition for which to define accessors.
  PUBLIC-SLOT-NAME: Public slot name for the field (without the #\% prefix)."
  (let* ((slot-name (proto-internal-field-name field))
         (public-accessor-name (proto-slot-function-name proto-type public-slot-name :get))
         (hidden-accessor-name (fintern "~A-~A" proto-type slot-name))
         (bool-index (proto-bool-index field))
         (bit-field-name (fintern "~A-%%BOOL-VALUES" proto-type)))
    (with-gensyms (obj)
      `((defun-inline ,public-accessor-name (,obj)
          ,(if bool-index
               `(plusp (bit (,bit-field-name ,obj) ,bool-index))
               `(,hidden-accessor-name ,obj)))

        ,@(make-common-forms-for-structure-class
           proto-type public-slot-name slot-name field)

        ;; Make special map forms.
        ,@(when (typep (find-map-descriptor (proto-class field)) 'map-descriptor)
            (make-map-accessor-forms
             proto-type public-slot-name slot-name field))))))


(let ((defaults (make-hash-table)))
  (loop for type in '(int32 uint32 fixed32 sfixed32 sint32
                      int64 uint64 fixed64 sfixed64 sint64)
        do (setf (gethash type defaults) 0))

  (setf (gethash 'double-float defaults) 0.0d0)
  (setf (gethash 'float defaults) 0.0)
  (setf (gethash 'boolean defaults) nil)
  (setf (gethash 'string defaults) "")
  (setf (gethash 'byte-vector defaults) '(make-byte-vector 0 :adjustable t))

  ;; Home grown types
  (setf (gethash 'cl:keyword defaults) :default-keyword)
  (setf (gethash 'cl:symbol defaults) nil)

  (defun get-default-form (type default container kind)
    "Find the default value for a specified type.

  Parameters:
    TYPE: The type we want to get the default form for.
    DEFAULT: A user defined default or one of nil $empty-default.
    CONTAINER: If the field we're getting the default for is repeated then
      the type of container to hold the repeated data in.
    KIND: The kind of message this is, one of :group :message :extends
      :enum :scalar."
    (let ((possible-default (gethash type defaults)))
      (cond
        ((not (member default (list $empty-default nil)))
         default)
        ((eq container :vector)
         `(make-array 0 :element-type ',type
                        :adjustable t
                        :fill-pointer 0))
        ((eq container :list) nil)
        ((member kind '(:group :message :extends))
         nil)
        ((eq type :map)
         '(make-hash-table))
        ((or possible-default
             (eq type 'cl:boolean))
         possible-default)
        ((enum-default-value `,type)
         (enum-default-value `,type))
        (t
         `(enum-default-value ',type))))))

(defun make-structure-class-forms (proto-type slots non-lazy-fields lazy-fields oneofs)
  "Makes the definition forms for the define-group and define-message macros.

 Parameters:
  PROTO-TYPE: The Lisp type name of the proto message.
  SLOTS: Slot definitions created by PROCESS-FIELD.
  NON-LAZY-FIELDS: Field definitions for non-lazy fields.
  LAZY-FIELDS: Field definitions for lazy fields.
  ONEOFS: A list of oneof descriptors for the message/group."
  (let* ((public-constructor-name (fintern "MAKE-~A" proto-type))
         (hidden-constructor-name (fintern "%MAKE-~A" proto-type))
         (public-lazy-slot-names (mapcar #'proto-external-field-name lazy-fields))
         (public-non-lazy-slot-names (mapcar #'proto-external-field-name non-lazy-fields))
         (is-set-name (fintern "~A-%%IS-SET" proto-type))
         (clear-is-set-name (fintern "~A.CLEAR-%%IS-SET" proto-type))
         (is-set-init (field-data-initform
                       (find-if #'(lambda (el)
                                    (eq (field-data-internal-slot-name el) '%%is-set))
                                slots)))
         (additional-slots '(%%is-set))
         (oneof-fields (loop for oneof in oneofs
                             append (coerce (oneof-descriptor-fields oneof) 'list))))
    (with-gensyms (obj)
      `(progn
         ;; DEFSTRUCT form.
         (declaim (inline ,hidden-constructor-name))
         (defstruct (,proto-type (:constructor ,hidden-constructor-name)
                                 (:include base-message)
                                 ;; Yet more class->struct code we have to add,
                                 ;; todo(jgodbout):delete asap
                                 (:predicate nil))
           ,@(remove nil
              (append
               (mapcar (lambda (slot)
                        (let ((name (field-data-internal-slot-name slot))
                              (type (field-data-type slot))
                              (initform (field-data-initform slot))
                              (container (field-data-container slot))
                              (kind (field-data-kind slot)))
                          (unless (eq type 'boolean)
                            `(,name ,(get-default-form type initform container kind) :type ,type))))
                       slots)
               (mapcar (lambda (oneof)
                         (let ((name (oneof-descriptor-internal-name oneof)))
                           `(,name (make-oneof) :type oneof)))
                       oneofs))))
         ;; Define public accessors for fields.
         ,@(mapcan (lambda (field public-slot-name)
                     (make-structure-class-forms-non-lazy proto-type
                                                          field
                                                          public-slot-name))
                   non-lazy-fields public-non-lazy-slot-names)
         ,@(mapcan (lambda (field public-slot-name)
                     (make-structure-class-forms-lazy proto-type field public-slot-name))
                   lazy-fields public-lazy-slot-names)

         ;; Define public accessors for oneofs.
         ,@(mapcan (lambda (oneof)
                     (make-oneof-accessor-forms proto-type oneof))
                   oneofs)

         ;; Define public constructor.
         (defun-inline ,public-constructor-name
             (&key
              ,@(loop for sn in public-non-lazy-slot-names
                      collect `(,sn :%unset))
              ,@(loop for sn in public-lazy-slot-names
                      collect `(,sn :%unset))
              ,@(loop for oneof in oneofs
                      collect`(,(oneof-descriptor-external-name oneof) :%unset))
              ,@(loop for field in oneof-fields
                      collect `(,(proto-external-field-name field) :%unset)))
           (let ((,obj (,hidden-constructor-name)))
             ,@(mapcan
                (lambda (field)
                  (let* ((type (proto-type field))
                         (public-slot-name (proto-external-field-name field))
                         (set-check (if (eq type 'cl:boolean)
                                        `(eq ,public-slot-name :%unset)
                                        `(or (eq ,public-slot-name :%unset)
                                             (not ,public-slot-name)))))
                    (let ((public-accessor-name
                            (proto-slot-function-name proto-type public-slot-name :get)))
                      `((unless ,set-check
                          (setf (,public-accessor-name ,obj) ,public-slot-name))))))
                (append non-lazy-fields
                        lazy-fields
                        oneof-fields))
             ,@(mapcan
                (lambda (oneof)
                  (let* ((public-slot-name (oneof-descriptor-external-name oneof))
                         (hidden-slot-name (oneof-descriptor-internal-name oneof))
                         (set-check `(or (eq ,public-slot-name :%unset)
                                         (not ,public-slot-name))))
                         `((unless ,set-check
                             (setf (slot-value ,obj ',hidden-slot-name) ,public-slot-name)))))
                oneofs)
             ,obj))

         ;; Define clear functions.
         (defun ,clear-is-set-name (,obj)
           (setf (,is-set-name ,obj) ,is-set-init))

         (export '(,public-constructor-name ,is-set-name))
         (defmethod clear ((,obj ,proto-type))
           (setf (base-message-%%skipped-bytes ,obj) nil)
           ,@(mapcan (lambda (name)
                       (let ((clear-name (fintern "~A.CLEAR-~A" proto-type name)))
                         `((,clear-name ,obj))))
                     (append public-non-lazy-slot-names additional-slots
                             (mapcar #'oneof-descriptor-external-name oneofs))))))))

(defun non-repeated-bool-field (field)
  "Determine if a field given by a FIELD is a non-repeated boolean."
  (and (member 'cl:boolean field)
       (not (member '(:repeated :list) field :test #'equal))
       (not (member '(:repeated :vector) field :test #'equal))))

;;; TODO(cgay): Is the NAME option used anymore, now that define-message isn't
;;; called directly in non-generated Lisp code?
(defmacro define-message (type (&key name conc-name alias-for options)
                          &body fields &environment env)
  "Define a new protobuf message struct type.

 Parameters:
   TYPE - Symbol naming the new type.
   NAME - Optional symbol used to override the defaultly generated protobuf message name.
   CONC-NAME - Prefix to the Lisp slot accessors, if supplied.
   ALIAS-FOR - If supplied, no Lisp struct is defined. Instead, the message is used
     as an alias for a class that already exists. This feature is intended to be
     used to define messages that will be serialized from existing Lisp classes;
     unless you get the slot names or readers exactly right for each field,
     trying to (de)serialize into a Lisp object won't work.
   OPTIONS - A set of keyword/value pairs, both of which are strings.
   FIELDS - Either field specs of the form (name :index n :type t ...) or
     define-{message,enum,oneof,map} forms. See process-field for more info."
  (let* ((name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (conc-name (conc-name-for-type type conc-name))
         (msg-desc (make-instance 'message-descriptor
                                  :class type
                                  :name  name
                                  :qualified-name (make-qualified-name
                                                   (or *current-message-descriptor*
                                                       *current-file-descriptor*)
                                                   name)
                                  :alias-for alias-for
                                  :conc-name conc-name
                                  :options (remove-options options "default" "packed")))
         (field-offset 0)
         (top-level-form-p (null *current-message-descriptor*))
         (*current-message-descriptor* msg-desc)
         (bool-count (count-if #'non-repeated-bool-field fields))
         (bool-index -1)
         (bool-values (make-array bool-count :element-type 'bit :initial-element 0)))
    (with-collectors ((slots collect-slot)
                      (forms collect-form)
                      ;; The typedef needs to be first in forms otherwise ccl warns.
                      ;; We'll collect them separately and splice them in first.
                      (type-forms collect-type-form)
                      (lazy-fields collect-lazy-field)
                      (non-lazy-fields collect-non-lazy-field)
                      (oneofs collect-oneof))
      (dolist (field fields)
        (case (car field)
          ((define-enum)
           (let ((result (macroexpand-1 field env)))
             (assert (eq (car result) 'progn) ()
                     "The macroexpansion for ~S failed" field)))
          ((define-message define-extend)
           (let ((result (macroexpand-1 field env)))
             (assert (eq (car result) 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-type-form (cdr result))))
          ((define-extension define-group define-map)
           (destructuring-bind (&optional progn model-type model definers extra-field extra-slot)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form definers)
             (case model-type
               ((define-group define-map)
                (when extra-slot
                  (collect-slot extra-slot))
                (setf (proto-field-offset extra-field) field-offset)
                (incf field-offset)
                (collect-non-lazy-field extra-field)
                (push extra-field (proto-fields msg-desc)))
               ((define-extension)
                (push model (proto-extensions msg-desc))))))
          ((define-oneof)
           (destructuring-bind (&optional progn oneof-desc)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed in DEFINE-MESSAGE" field)
             (when oneof-desc
               (push oneof-desc (proto-oneofs msg-desc))
               (collect-oneof oneof-desc))))
          (otherwise
           (multiple-value-bind (field slot idx offset-p)
               (process-field field :conc-name conc-name
                                    :alias-for alias-for
                                    :field-offset field-offset
                                    :bool-index
                                    (when (non-repeated-bool-field field)
                                      (incf bool-index))
                                    :bool-values bool-values)
             (declare (ignore idx))
             (when offset-p
               (incf field-offset))
             (if (proto-lazy-p field)
                 (collect-lazy-field field)
                 (collect-non-lazy-field field))
             (assert (not (find-field msg-desc (proto-index field))) ()
                     "The field ~S overlaps with another field in ~S"
                     ;; TODO(cgay): this should probably refer to the external field name but I'll
                     ;; wait since I've no idea if that slot is bound at this point.
                     (proto-internal-field-name field) (proto-class msg-desc))
             (when slot
               (collect-slot slot))
             (push field (proto-fields msg-desc))))))
      ;; Not required, but this will have the proto-fields serialized
      ;; in the order they were defined.
      (setf (proto-fields msg-desc) (nreverse (proto-fields msg-desc)))
      ;; One extra slot for the make-message-with-bytes feature.
      (collect-slot
       (make-field-data
        :internal-slot-name 'proto-impl::%bytes
        :external-slot-name 'proto-impl::%bytes
        :type '(or null (simple-array (unsigned-byte 8)))
        :initarg :%bytes
        :initform nil))

      (unless (= bool-index -1)
        (collect-slot
         (make-field-data
          :internal-slot-name 'proto-impl::%%bool-values
          :external-slot-name 'proto-impl::%%bool-values
          :type `(bit-vector ,bool-count)
          :initarg :%%bool-values
          :container :vector
          :initform `(make-array ,bool-count :element-type 'bit
                                             :initial-contents ,bool-values))))

      ;; todo(jgodbout): Storing the is-set vector as N >= 1 slots of
      ;; type sb-ext:word rather than 1 slot as a bit-vector would reduce
      ;; the memory reads by 1 per slot access.
      (collect-slot
       (make-field-data
        :internal-slot-name 'proto-impl::%%is-set
        :external-slot-name 'proto-impl::%%is-set
        :type `(bit-vector ,field-offset)
        :initarg :%%is-set
        :container :vector
        :initform `(make-array ,field-offset
                               :element-type 'bit
                               :initial-element 0)))
      (if alias-for
          ;; If we've got an alias, define a type that is the subtype of the Lisp class so that
          ;; typep and subtypep work.  Unless alias-for is a type which is not yet defined (as is
          ;; usually the case), in which case just define a vacuous type for the message.
          (unless (or (eq type alias-for) (find-class type nil))
            (let* ((alias-class (find-class alias-for nil))
                   (alias-type (or (and alias-class (class-name alias-class))
                                   t)))
              (collect-type-form `(deftype ,type () ',alias-type))
              (collect-form `(record-protobuf-object ',alias-for ,msg-desc :message))))
          ;; If no alias, define the class now
          (collect-type-form
           (make-structure-class-forms type slots non-lazy-fields lazy-fields oneofs)))
      ;; Register it by the full symbol name.
      (record-protobuf-object type msg-desc :message)
      (collect-form `(record-protobuf-object ',type ,msg-desc :message))
      (create-progn-with-enum-forms-if-top-level top-level-form-p type-forms forms))))

(defun conc-name-for-type (type conc-name)
  (and conc-name
       (typecase conc-name
         ((member t) (format nil "~:@(~A~)-" type))
         ((or string symbol) (string-upcase (string conc-name)))
         (t nil))))

(defmacro define-extension (from to)
  "Define an extension range within a message. FROM and TO are field numbers
   and are both inclusive."
  (let ((to (etypecase to
              (integer to)
              (symbol (if (string-equal to "MAX") +max-field-number+ to)))))
    `(progn
       define-extension
       ,(make-instance 'extension-descriptor
                       :from from
                       :to (if (eq to 'max) +max-field-number+ to))
       ())))

(defmacro define-extend (type (&key name conc-name options) &body fields &environment env)
  "Define an extension to the message named TYPE. See define-message for descriptions of the
   NAME, CONC-NAME, OPTIONS, and FIELDS parameters."
  (let* ((name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (message   (find-message type))
         (conc-name (or (conc-name-for-type type conc-name)
                        (and message (proto-conc-name message))))
         (alias-for (and message (proto-alias-for message)))
         (extends (and message
                       (make-instance
                        'message-descriptor
                        :class  (proto-class message)
                        :name   (proto-name message)
                        :qualified-name (proto-qualified-name message)
                        :alias-for alias-for
                        :conc-name conc-name
                        :fields   (copy-list (proto-fields message))
                        :extensions (copy-list (proto-extensions message))
                        :options  (remove-options
                                   (or options (copy-list (proto-options message)))
                                   "default" "packed")
                        :message-type :extends))) ; this message is an extension
         (top-level-form-p (null *current-message-descriptor*))
         ;; Only now can we bind *current-message-descriptor* to the new extended message
         (*current-message-descriptor* extends))
    (assert message ()
            "There is no message named ~A to extend" name)
    (assert (eq type (proto-class message)) ()
            "The type ~S doesn't match the type of the message being extended ~S"
            type message)
    (with-collectors ((forms collect-form))
      (dolist (field fields)
        (assert (not (member (car field)
                             '(define-enum define-message define-extend define-extension)))
                () "The body of ~S can only contain field and group definitions" 'define-extend)
        (case (car field)
          ((define-group)
           (destructuring-bind (&optional progn model-type model definers extra-field extra-slot)
               (macroexpand-1 field env)
             (declare (ignore model))
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form definers)
             (case model-type
               ((define-group)
                (when extra-slot
                  ;;--- Refactor to get rid of all this duplicated code!
                  (let* ((sname  (field-data-internal-slot-name extra-slot))
                         ;; The field name
                         (fname (field-data-external-slot-name extra-slot))
                         (stable (fintern "~A-VALUES" sname))
                         (stype (field-data-type extra-slot))
                         (reader (or (field-data-accessor extra-slot)
                                     (if conc-name
                                         (fintern "~A~A" conc-name sname)
                                         (symbol-name sname))))
                         (writer (fintern "~A-~A" 'set reader))
                         (default (field-data-initform extra-slot)))
                    (collect-form `(without-redefinition-warnings ()
                                     (let ((,stable (tg:make-weak-hash-table
                                                     :weakness :key :test #'eq)))
                                       ,@(and reader `((defmethod ,reader ((object ,type))
                                                         (gethash object ,stable ,default))))
                                       ,@(and writer `((defmethod ,writer ((object ,type) ,stype)
                                                         #-ccl (declare (type ,stype value))
                                                         (setf (gethash object ,stable) value))))
                                       ;; For Python compatibility
                                       (defmethod get-extension ((object ,type)
                                                                 (slot (eql ',fname)))
                                         (values (gethash object ,stable ,default)))
                                       ;; Set and has need to be defined for sname and fname
                                       ;; for usefulness to reader and serialization
                                       (defmethod set-extension ((object ,type)
                                                                 (slot (eql ',sname))
                                                                 value)
                                         (setf (gethash object ,stable) value))
                                       (defmethod set-extension ((object ,type)
                                                                 (slot (eql ',fname))
                                                                 value)
                                         (setf (gethash object ,stable) value))
                                       (defmethod has-extension ((object ,type)
                                                                 (slot (eql ',fname)))
                                         (multiple-value-bind (value foundp)
                                             (gethash object ,stable)
                                           (declare (ignore value))
                                           foundp))
                                       (defmethod has-extension ((object ,type)
                                                                 (slot (eql ',sname)))
                                         (multiple-value-bind (value foundp)
                                             (gethash object ,stable)
                                           (declare (ignore value))
                                           foundp))
                                       (defmethod clear-extension ((object ,type)
                                                                   (slot (eql ',fname)))
                                         (remhash object ,stable))
                                       (defmethod (setf ,reader)
                                           (val (object ,type))
                                         (,writer object val)))))))
                (setf (proto-kind extra-field) :extends)
                (appendf (proto-fields extends) (list extra-field))
                (appendf (proto-extended-fields extends) (list extra-field))))))
          (otherwise
           (multiple-value-bind (field slot idx)
               (process-field field :conc-name conc-name :alias-for alias-for)
             (assert (index-within-extensions-p idx message) ()
                     "The index ~D is not in range for extending ~S"
                     idx (proto-class message))
             (when slot
               (let* (;; The slot name which is the %field-name
                      (sname  (field-data-internal-slot-name slot))
                      ;; The field name
                      (fname (field-data-external-slot-name slot))
                      (stable (fintern "~A-VALUES" sname))
                      (stype (field-data-type slot))
                      (reader (or (field-data-accessor slot)
                                  (if conc-name
                                      (fintern "~A~A" conc-name sname)
                                      (symbol-name sname))))
                      (writer (fintern "~A-~A" 'set reader))
                      (default (field-data-initform slot)))
                 ;; For the extended slots, each slot gets its own table
                 ;; keyed by the object, which lets us avoid having a slot in each
                 ;; instance that holds a table keyed by the slot name
                 ;; Multiple 'define-extends' on the same class in the same image
                 ;; will result in harmless redefinitions, so squelch the warnings
                 ;;--- Maybe these methods need to be defined in 'define-message'?
                 (collect-form
                  `(without-redefinition-warnings ()
                     (let ((,stable (tg:make-weak-hash-table :weakness :key :test #'eq)))
                       ,@(and reader `((defmethod ,reader ((object ,type))
                                         (gethash object ,stable ,default))))
                       ,@(and writer `((defmethod ,writer ((object ,type) value)
                                         #-ccl (declare (type ,stype value))
                                         (setf (gethash object ,stable) value))))
                       (defmethod get-extension ((object ,type) (slot (eql ',fname)))
                         (values (gethash object ,stable ,default)))
                       ;; Set and has need to be defined for sname and fname
                       ;; for usefulness to reader and serialization
                       (defmethod set-extension ((object ,type) (slot (eql ',sname)) value)
                         (setf (gethash object ,stable) value))
                       (defmethod set-extension ((object ,type) (slot (eql ',fname)) value)
                         (setf (gethash object ,stable) value))
                       (defmethod has-extension ((object ,type) (slot (eql ',fname)))
                         (multiple-value-bind (value foundp)
                             (gethash object ,stable)
                           (declare (ignore value))
                           foundp))
                       (defmethod has-extension ((object ,type) (slot (eql ',sname)))
                         (multiple-value-bind (value foundp)
                             (gethash object ,stable)
                           (declare (ignore value))
                           foundp))
                       (defmethod clear-extension ((object ,type) (slot (eql ',fname)))
                         (remhash object ,stable))
                       (defmethod (setf ,reader)
                           (val (object ,type))
                         (,writer object val)))))
                 ;; This so that (de)serialization works
                 (setf (proto-reader field) reader)))
             (setf (proto-kind field) :extends)
             (appendf (proto-fields extends) (list field))
             (appendf (proto-extended-fields extends) (list field))))))
      (collect-form `(record-protobuf-object ',type ,extends :message))
      (create-progn-with-enum-forms-if-top-level top-level-form-p forms))))

(defun index-within-extensions-p (index message)
  (let ((extensions (proto-extensions message)))
    (some #'(lambda (ext)
              (and (i>= index (proto-extension-from ext))
                   (i<= index (proto-extension-to ext))))
          extensions)))

(defmacro define-group (type (&key index label name conc-name alias-for reader options)
                        &body fields &environment env)
  "Define a new protobuf message struct AND a field named by TYPE.
 Parameters:
   TYPE, INDEX, NAME, CONC-NAME, ALIAS-FOR, and OPTIONS are as for define-message.
   LABEL - nil (proto3), :required, :optional or :repeated.
   READER - A symbol naming a function to use to get the value, instead of
     using slot-value; this is often used when aliasing an existing class."
  (check-type index integer)
  (check-type label (member :required :optional :repeated))
  (let* ((slot    (or type (and name (proto->slot-name name *package*))))
         (name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (conc-name (conc-name-for-type type conc-name))
         (reader  (or reader
                      (let ((msg-conc (proto-conc-name *current-message-descriptor*)))
                        (and msg-conc
                             (fintern "~A~A" msg-conc slot)))))
         (internal-slot-name (fintern "%~A" slot))
         (mslot   (unless alias-for
                    (make-field-data
                     :internal-slot-name internal-slot-name
                     :external-slot-name slot
                     :type
                     (case label
                       (:required (list 'cl:or 'cl:null `,type))
                       (:optional (list 'cl:or 'cl:null `,type))
                       (:repeated (list 'proto:list-of `,type)))
                     :initform nil
                     :accessor reader
                     :container (when (eq label :repeated) :list)
                     :initarg (kintern (symbol-name slot))
                     :kind :group)))
         (mfield  (make-instance 'field-descriptor
                    :name  (slot-name->proto slot)
                    :class type
                    :qualified-name (make-qualified-name *current-message-descriptor*
                                                         (slot-name->proto slot))
                    :type type
                    :label label
                    :index index
                    :internal-field-name internal-slot-name
                    :external-field-name slot
                    :reader reader
                    :kind :group))
         (message (make-instance 'message-descriptor
                    :class type
                    :name  name
                    :qualified-name (make-qualified-name *current-message-descriptor* name)
                    :alias-for alias-for
                    :conc-name conc-name
                    :options   (remove-options options "default" "packed")
                    :message-type :group)) ; this message is a group
         (field-offset 0)
         (bool-count (count-if #'non-repeated-bool-field fields))
         (bool-index -1)
         (bool-values (make-array bool-count :element-type 'bit :initial-element 0))
         ;; Only now can we bind *current-message-descriptor* to the (group) message.
         (*current-message-descriptor* message))
    (with-collectors ((slots collect-slot)
                      (forms collect-form)
                      ;; The typedef needs to be first in forms otherwise ccl warns.
                      ;; We'll collect them separately and splice them in first.
                      (type-forms collect-type-form)
                      (lazy-fields collect-lazy-field)
                      (non-lazy-fields collect-non-lazy-field)
                      (oneofs collect-oneof))
      (dolist (field fields)
        (case (car field)
          ((define-enum define-message define-extend)
           (let ((result (macroexpand-1 field env)))
             (assert (eq (car result) 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-form (cdr result))))
          ((define-extension define-group define-map)
           (destructuring-bind (&optional progn model-type model definers extra-field extra-slot)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (map () #'collect-type-form definers)
             (case model-type
               ((define-group define-map)
                (setf (proto-field-offset extra-field) field-offset)
                (incf field-offset)
                (collect-non-lazy-field extra-field)
                (when extra-slot
                  (collect-slot extra-slot))
                (appendf (proto-fields message) (list extra-field)))
               ((define-extension)
                (appendf (proto-extensions message) (list model))))))
          ((define-oneof)
           (destructuring-bind (&optional progn oneof-desc)
               (macroexpand-1 field env)
             (assert (eq progn 'progn) ()
                     "The macroexpansion for ~S failed" field)
             (when oneof-desc
               (appendf (proto-oneofs message) (list oneof-desc))
               (collect-oneof oneof-desc))))
          (otherwise
           (multiple-value-bind (field slot idx offset-p)
               (process-field field :conc-name conc-name
                                    :alias-for alias-for
                                    :field-offset field-offset
                                    :bool-index
                                    (when (non-repeated-bool-field field)
                                      (incf bool-index))
                                    :bool-values bool-values)
             (declare (ignore idx))
             (when offset-p
               (incf field-offset))
             (if (proto-lazy-p field)
                 (collect-lazy-field field)
                 (collect-non-lazy-field field))
             (assert (not (find-field message (proto-index field))) ()
                     "The field ~S overlaps with another field in ~S"
                     (proto-internal-field-name field) (proto-class message))
             (when slot
               (collect-slot slot))
             (appendf (proto-fields message) (list field))))))
      ;; todo(jgodbout): Storing the is-set vector as N >= 1 slots of
      ;; type sb-ext:word rather than 1 slot as a bit-vector would reduce
      ;; the memory reads by 1 per slot access.
      (collect-slot
       (make-field-data
          :internal-slot-name 'proto-impl::%%is-set
          :external-slot-name 'proto-impl::%%is-set
          :type `(bit-vector ,field-offset)
          :initarg :%%is-set
          :container :vector
          :initform `(make-array ,field-offset
                                 :element-type 'bit
                                 :initial-element 0)))

      (unless (= bool-index -1)
        (collect-slot
         (make-field-data
          :internal-slot-name 'proto-impl::%%bool-values
          :external-slot-name 'proto-impl::%%bool-values
          :type `(bit-vector ,bool-count)
          :initarg :%%bool-values
          :container :vector
          :initform `(make-array ,bool-count :element-type 'bit
                                             :initial-contents ,bool-values))))

      (if alias-for
        ;; If we've got an alias, define a a type that is the subtype of
        ;; the Lisp class that typep and subtypep work
        (unless (or (eq type alias-for) (find-class type nil))
          (collect-type-form `(deftype ,type () ',alias-for)))
          (collect-type-form
           (make-structure-class-forms type slots non-lazy-fields lazy-fields oneofs)))
      (collect-form `(record-protobuf-object ',type ,message :message))
      ;; Group can never be a top level element.
      `(progn
         define-group
         ,message
         (
          ,@type-forms
          ,@forms)
         ,mfield
         ,mslot))))

(defun process-field (field &key conc-name alias-for field-offset bool-index bool-values)
  "Process one field descriptor within 'define-message' or 'define-extend'.
   Returns a field-descriptor object, a defstruct slot form, the field number,
   and a boolean indicating whether FIELD has an offset.

 Parameters:
   FIELD: A list whose first element is the Lisp symbol for the field name, followed
     by keyword / value pairs:
     :type - A symbol naming the Lisp type of this field.
     :index - The field number.
     :name - Optional. Used to override the defaultly generated protobuf field name.
     :default - Optional. The default value for the slot.
     :packed - Determines if the field is packed with respect to the proto API.
     :lazy - Determines whether to lazily deserialize the field with respect to the proto API.
     :label - One of (:repeated :vector), (:repeated :list), (:optional), (:required).
     :kind - One of :enum :map :scalar :group :message :extends
   CONC-NAME: The name to concatenate to the beginning of the field accessor.
   ALIAS-FOR is to determine if this is an alias for a difference field.
   FIELD-OFFSET is an internal concept of the index of a field
     in a proto-message.
   BOOL-INDEX: nil if this is not a simple (non-repeated) boolean field.
     If this is a simple boolean field, this is the index into the bit vector of all
     simple boolean fields (i.e., the bool-values argument).
   BOOL-VALUES: A bit-vector holding all boolean values for a message.
     On exit this vector holds the correct default value for FIELD if it is a
     simple boolean field."
  (destructuring-bind (slot &key type name (default nil default-p) packed lazy
                            json-name index label kind &allow-other-keys)
      field
    (assert json-name)
    (let* (;; Public accessors and setters for slots should be defined later.
           (internal-slot-name (fintern "%~A" slot))
           (reader (and conc-name
                        (fintern "~A~A" conc-name slot))))
      (multiple-value-bind (ptype pclass)
          (clos-type-to-protobuf-type type)
        (declare (ignore ptype))
        (assert index)
        (multiple-value-bind (label repeated-storage-type) (values-list label)
          (let* (;; Proto3 optional fields do not have offsets, as they don't have has-* functions.
                 ;; Note that proto2-style optional fields in proto3 files are wrapped in oneofs by
                 ;; protoc, and hence process-field is never called.
                 (offset (and (not (eq (proto-syntax *current-file-descriptor*) :proto3))
                              field-offset))
                 (default
                  (if default-p
                      default
                      $empty-default))
                 (cslot (unless alias-for
                          (make-field-data
                           :internal-slot-name internal-slot-name
                           :external-slot-name slot
                           :type
                           (cond ((and (eq label :repeated) (eq repeated-storage-type :vector))
                                  (list 'proto:vector-of `,type))
                                 ((and (eq label :repeated) (eq repeated-storage-type :list))
                                  (list 'proto:list-of `,type))
                                 ((member kind '(:message :group))
                                  (list 'cl:or 'cl:null `,type))
                                 (t `,type))
                           :accessor reader
                           :initarg (kintern (symbol-name slot))
                           :container (when (eq label :repeated) repeated-storage-type)
                           :kind kind
                           :initform
                           (cond ((eq label :repeated)
                                     ;; Repeated fields get a container for their elements
                                     (if (eq repeated-storage-type :vector)
                                         `(make-array 5 :fill-pointer 0 :adjustable t)
                                         nil))
                                 ((and (not default-p)
                                          (eq label :optional)
                                          ;; Use unbound for booleans only
                                          (not (eq pclass :bool)))
                                  nil)
                                 (default-p `,default)))))
                 (field (make-instance
                         'field-descriptor
                         :name  (or name (slot-name->proto slot))
                         :type type
                         :kind kind
                         :class pclass
                         :qualified-name (make-qualified-name *current-message-descriptor*
                                                              (or name (slot-name->proto slot)))
                         :label label
                         :index  index
                         :field-offset offset
                         :internal-field-name internal-slot-name
                         :external-field-name slot
                         :json-name json-name
                         :reader reader
                         :default default
                         ;; Pack the field only if requested and it actually makes sense
                         :packed  (and (eq label :repeated) packed t)
                         :container (when (eq label :repeated) repeated-storage-type)
                         :lazy (and lazy t)
                         :bool-index bool-index)))
            (when (and bool-index default (not (eq default $empty-default)))
              (setf (bit bool-values bool-index) 1))
            (values field cslot index (and offset t))))))))

(defparameter *rpc-package* nil
  "The Lisp package that implements RPC.
   This should be set when an RPC package that uses CL-Protobufs gets loaded.")
(defparameter *rpc-call-function* nil
  "The Lisp function that implements RPC client-side calls.
   This should be set when an RPC package that uses CL-Protobufs gets loaded.")

(defmacro define-service (type (&key name options source-location) &body method-specs)
  "Define a service named TYPE and a generic function for each method.
   NAME can be used to override the defaultly generated service name.
   OPTIONS is a set of keyword/value pairs, both of which are strings.
   SOURCE-LOCATION is an optional source location.

   The body is a set of METHOD-SPECS of the form (name (input-type [=>] output-type) &key options).
   INPUT-TYPE and OUTPUT-TYPE may also be of the form (type &key name)."
  (let* ((name    (or name (class-name->proto type)))
         (options (loop for (key val) on options by #'cddr
                        collect
                        (make-option (if (symbolp key) (slot-name->proto key) key) val)))
         (service (make-instance 'service-descriptor
                                 :class type
                                 :name  name
                                 :qualified-name (make-qualified-name *current-file-descriptor*
                                                                      name)
                                 :options options
                                 :source-location source-location))
         (index 0))
    (with-collectors ((forms collect-form))
      (dolist (method method-specs)
        (destructuring-bind (function (&rest types) &key name options)
            method
          (let* ((input-type   (first types))
                 (output-type  (if (string= (string (second types)) "=>")
                                   (third types)
                                   (second types)))
                 (streams-type (if (string= (string (second types)) "=>")
                                   (getf (cdddr types) :streams)
                                   (getf (cddr  types) :streams)))
                 (input-name (and (listp input-type)
                                  (getf (cdr input-type) :name)))
                 (input-streaming (and (listp input-type)
                                       (getf (cdr input-type) :stream)))
                 (input-type (if (listp input-type) (car input-type) input-type))
                 (qual-input-type (make-qualified-name *current-file-descriptor*
                                                       (class-name->proto input-type)))
                 (output-name (and (listp output-type)
                                   (getf (cdr output-type) :name)))
                 (output-streaming (and (listp output-type)
                                        (getf (cdr output-type) :stream)))
                 (output-type (if (listp output-type) (car output-type) output-type))
                 (qual-output-type (make-qualified-name *current-file-descriptor*
                                                        (class-name->proto output-type)))
                 (streams-name (and (listp streams-type)
                                    (getf (cdr streams-type) :name)))
                 (streams-type (if (listp streams-type) (car streams-type) streams-type))
                 (options (loop for (key val) on options by #'cddr
                                collect (make-option
                                         (if (symbolp key)
                                             (slot-name->proto key)
                                             key)
                                         val)))
                 (package (let ((name (strcat (package-name *package*) "-RPC")))
                            (or (find-package name)
                                (make-package name :use '()))))
                 (client-fn (intern (nstring-upcase (format nil "CALL-~A" function)) package))
                 (server-fn (intern (nstring-upcase (format nil "~A-IMPL" function)) package))
                 (method  (make-instance
                           'method-descriptor
                           :class function
                           :name  (or name (class-name->proto function))
                           :qualified-name (make-qualified-name *current-file-descriptor*
                                                                (or name
                                                                    (class-name->proto function)))
                           :service-name (proto-impl::proto-name service)
                           :client-stub client-fn
                           :server-stub server-fn
                           :input-type  input-type
                           :input-name  (or input-name qual-input-type)
                           :input-streaming input-streaming
                           :output-type output-type
                           :output-name (or output-name qual-output-type)
                           :output-streaming output-streaming
                           :streams-type streams-type
                           :streams-name (and streams-type
                                              (or streams-name (class-name->proto streams-type)))
                           :index (iincf index)
                           :options options)))
            (appendf (proto-methods service) (list method))
            ;; The following are the hooks to an RPC implementation
            (let* ((vrequest  (intern "REQUEST" package))
                   (vresponse (intern "RESPONSE" package))
                   (vchannel  (intern "CHANNEL" package))
                   (vcallback (intern "CALLBACK" package))
                   (vrpc      (intern "RPC" package)))
              ;; The client side stub, e.g., 'read-air-reservation'.
              ;; The expectation is that the RPC implementation will provide code to make it
              ;; easy to implement a method for this on each kind of channel (HTTP, TCP socket,
              ;; IPC, etc). Unlike C++/Java/Python, we don't need a client-side subclass,
              ;; because we can just use multi-methods.
              ;; The 'do-XXX' method calls the RPC code with the channel, the method
              ;; (i.e., a 'method-descriptor' object), the request and the callback function.
              ;; The RPC code should take care of serializing the input, transmitting the
              ;; request over the wire, waiting for input (or not, if it's asynchronous),
              ;; filling in the output, and either returning the response (if synchronous)
              ;; or calling the callback with the response as an argument (if asynchronous).
              ;; It will also deserialize the response so that the client code sees the
              ;; response as an application object.
              (collect-form
               `(defgeneric ,client-fn (,vchannel ,vrequest &key ,vcallback ,vresponse)
                  #+(or ccl)
                  (declare (values ,output-type))
                  (:method (,vchannel ,vrequest &key ,vcallback ,vresponse)
                    (declare (ignorable ,vchannel ,vcallback))
                    (let ((call (and *rpc-package* *rpc-call-function*)))
                      (assert call ()
                              "There is no RPC package loaded!")
                      (funcall call ,vchannel ',method ,vrequest ,vresponse
                               :callback ,vcallback
                                        ; :type ',input-type
                               )))))
              ;; The server side stub, e.g., 'do-read-air-reservation'.
              ;; The expectation is that the server-side program will implement
              ;; a method with the business logic for this on each kind of channel
              ;; (HTTP, TCP socket, IPC, etc), possibly on a server-side subclass
              ;; of the input class.
              ;; The business logic is expected to perform the correct operations on
              ;; the input object, which arrived via Protobufs, and produce an output
              ;; of the given type, which will be serialized and sent back over the wire.
              ;; The channel objects hold client identity information, deadline info,
              ;; etc, and can be side-effected to indicate success or failure.
              ;; The RPC code provides the channel classes and does (de)serialization, etc.
              ;; The VRPC argument is always of type RPC2:SERVER-RPC.
              (collect-form `(defgeneric ,server-fn (,vchannel ,vrequest ,vrpc)
                               #+(or ccl)
                               (declare (values ,output-type))))))))
      (collect-form `(appendf (proto-services *current-file-descriptor*) (list ,service)))
      `(progn ,@forms))))
